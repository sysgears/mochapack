{
  "version": 3,
  "sources": ["../node_modules/commander/lib/error.js", "../node_modules/commander/lib/argument.js", "../node_modules/commander/lib/help.js", "../node_modules/commander/lib/option.js", "../node_modules/commander/lib/suggestSimilar.js", "../node_modules/commander/lib/command.js", "../node_modules/commander/index.js", "../node_modules/detect-indent/index.js", "../node_modules/semver/internal/constants.js", "../node_modules/semver/internal/debug.js", "../node_modules/semver/internal/re.js", "../node_modules/semver/internal/parse-options.js", "../node_modules/semver/internal/identifiers.js", "../node_modules/semver/classes/semver.js", "../node_modules/semver/functions/parse.js", "../node_modules/semver/functions/valid.js", "../node_modules/semver/functions/clean.js", "../node_modules/semver/functions/inc.js", "../node_modules/semver/functions/diff.js", "../node_modules/semver/functions/major.js", "../node_modules/semver/functions/minor.js", "../node_modules/semver/functions/patch.js", "../node_modules/semver/functions/prerelease.js", "../node_modules/semver/functions/compare.js", "../node_modules/semver/functions/rcompare.js", "../node_modules/semver/functions/compare-loose.js", "../node_modules/semver/functions/compare-build.js", "../node_modules/semver/functions/sort.js", "../node_modules/semver/functions/rsort.js", "../node_modules/semver/functions/gt.js", "../node_modules/semver/functions/lt.js", "../node_modules/semver/functions/eq.js", "../node_modules/semver/functions/neq.js", "../node_modules/semver/functions/gte.js", "../node_modules/semver/functions/lte.js", "../node_modules/semver/functions/cmp.js", "../node_modules/semver/functions/coerce.js", "../node_modules/semver/internal/lrucache.js", "../node_modules/semver/classes/range.js", "../node_modules/semver/classes/comparator.js", "../node_modules/semver/functions/satisfies.js", "../node_modules/semver/ranges/to-comparators.js", "../node_modules/semver/ranges/max-satisfying.js", "../node_modules/semver/ranges/min-satisfying.js", "../node_modules/semver/ranges/min-version.js", "../node_modules/semver/ranges/valid.js", "../node_modules/semver/ranges/outside.js", "../node_modules/semver/ranges/gtr.js", "../node_modules/semver/ranges/ltr.js", "../node_modules/semver/ranges/intersects.js", "../node_modules/semver/ranges/simplify.js", "../node_modules/semver/ranges/subset.js", "../node_modules/semver/index.js", "../node_modules/micromatch/node_modules/braces/lib/utils.js", "../node_modules/micromatch/node_modules/braces/lib/stringify.js", "../node_modules/micromatch/node_modules/is-number/index.js", "../node_modules/micromatch/node_modules/to-regex-range/index.js", "../node_modules/micromatch/node_modules/fill-range/index.js", "../node_modules/micromatch/node_modules/braces/lib/compile.js", "../node_modules/micromatch/node_modules/braces/lib/expand.js", "../node_modules/micromatch/node_modules/braces/lib/constants.js", "../node_modules/micromatch/node_modules/braces/lib/parse.js", "../node_modules/micromatch/node_modules/braces/index.js", "../node_modules/picomatch/lib/constants.js", "../node_modules/picomatch/lib/utils.js", "../node_modules/picomatch/lib/scan.js", "../node_modules/picomatch/lib/parse.js", "../node_modules/picomatch/lib/picomatch.js", "../node_modules/picomatch/index.js", "../node_modules/micromatch/index.js", "../node_modules/queue-tick/queue-microtask.js", "../node_modules/queue-tick/process-next-tick.js", "../node_modules/fast-fifo/fixed-size.js", "../node_modules/fast-fifo/index.js", "../node_modules/b4a/index.js", "../node_modules/text-decoder/lib/pass-through-decoder.js", "../node_modules/text-decoder/lib/utf8-decoder.js", "../node_modules/text-decoder/index.js", "../node_modules/streamx/index.js", "../node_modules/tar-stream/headers.js", "../node_modules/tar-stream/extract.js", "../node_modules/tar-stream/constants.js", "../node_modules/tar-stream/pack.js", "../node_modules/tar-stream/index.js", "../src/cli/index.ts", "../node_modules/commander/esm.mjs", "../src/cli/add/index.ts", "../src/cache/index.ts", "../src/constants.ts", "../package.json", "../src/resolver/registry.ts", "../src/net/index.ts", "../src/cli/add/addScript.ts", "../src/resolver/resolver.ts", "../src/resolver/workspace.ts", "../src/resolver/resolveScript.ts", "../src/resolver/dependencies.ts", "../src/hoister/decision.ts", "../src/hoister/priority.ts", "../src/hoister/workspace.ts", "../src/hoister/hoist.ts", "../src/installer/installScript.ts", "../src/installer/installer.ts", "../src/runCommand.ts", "../src/cli/install/index.ts", "../src/cli/remove/index.ts", "../src/cli/remove/removeScript.ts"],
  "sourcesContent": ["/**\n * CommanderError class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n", "const { InvalidArgumentError } = require('./error.js');\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  }\n\n  /**\n   * @package\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Only allow argument value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(\n          `Allowed choices are ${this.argChoices.join(', ')}.`,\n        );\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Make argument required.\n   *\n   * @returns {Argument}\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make argument optional.\n   *\n   * @returns {Argument}\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n", "const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);\n    const helpCommand = cmd._getHelpCommand();\n    if (helpCommand && !helpCommand._hidden) {\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: because overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Compare options for sort.\n   *\n   * @param {Option} a\n   * @param {Option} b\n   * @returns {number}\n   */\n  compareOptions(a, b) {\n    const getSortKey = (option) => {\n      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.\n      return option.short\n        ? option.short.replace(/^-/, '')\n        : option.long.replace(/^--/, '');\n    };\n    return getSortKey(a).localeCompare(getSortKey(b));\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Built-in help option.\n    const helpOption = cmd._getHelpOption();\n    if (helpOption && !helpOption.hidden) {\n      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.\n      const removeShort = helpOption.short && cmd._findOption(helpOption.short);\n      const removeLong = helpOption.long && cmd._findOption(helpOption.long);\n      if (!removeShort && !removeLong) {\n        visibleOptions.push(helpOption); // no changes needed\n      } else if (helpOption.long && !removeLong) {\n        visibleOptions.push(\n          cmd.createOption(helpOption.long, helpOption.description),\n        );\n      } else if (helpOption.short && !removeShort) {\n        visibleOptions.push(\n          cmd.createOption(helpOption.short, helpOption.description),\n        );\n      }\n    }\n    if (this.sortOptions) {\n      visibleOptions.sort(this.compareOptions);\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the visible global options. (Not including help.)\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleGlobalOptions(cmd) {\n    if (!this.showGlobalOptions) return [];\n\n    const globalOptions = [];\n    for (\n      let ancestorCmd = cmd.parent;\n      ancestorCmd;\n      ancestorCmd = ancestorCmd.parent\n    ) {\n      const visibleOptions = ancestorCmd.options.filter(\n        (option) => !option.hidden,\n      );\n      globalOptions.push(...visibleOptions);\n    }\n    if (this.sortOptions) {\n      globalOptions.sort(this.compareOptions);\n    }\n    return globalOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd.registeredArguments.forEach((argument) => {\n        argument.description =\n          argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd.registeredArguments.find((argument) => argument.description)) {\n      return cmd.registeredArguments;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd.registeredArguments\n      .map((arg) => humanReadableArgName(arg))\n      .join(' ');\n    return (\n      cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '')\n    );\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest global option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestGlobalOptionTermLength(cmd, helper) {\n    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let ancestorCmdNames = '';\n    for (\n      let ancestorCmd = cmd.parent;\n      ancestorCmd;\n      ancestorCmd = ancestorCmd.parent\n    ) {\n      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;\n    }\n    return ancestorCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: because overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatibility.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: because overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,\n      );\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault =\n        option.required ||\n        option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(\n          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,\n        );\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,\n      );\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(\n        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,\n      );\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(\n          fullText,\n          helpWidth - itemIndentWidth,\n          termWidth + itemSeparatorWidth,\n        );\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([\n        helper.wrap(commandDescription, helpWidth, 0),\n        '',\n      ]);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(\n        helper.argumentTerm(argument),\n        helper.argumentDescription(argument),\n      );\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(\n        helper.optionTerm(option),\n        helper.optionDescription(option),\n      );\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    if (this.showGlobalOptions) {\n      const globalOptionList = helper\n        .visibleGlobalOptions(cmd)\n        .map((option) => {\n          return formatItem(\n            helper.optionTerm(option),\n            helper.optionDescription(option),\n          );\n        });\n      if (globalOptionList.length > 0) {\n        output = output.concat([\n          'Global Options:',\n          formatList(globalOptionList),\n          '',\n        ]);\n      }\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(\n        helper.subcommandTerm(cmd),\n        helper.subcommandDescription(cmd),\n      );\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestGlobalOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper),\n    );\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Full \\s characters, minus the linefeeds.\n    const indents =\n      ' \\\\f\\\\t\\\\v\\u00a0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff';\n    // Detect manually wrapped and indented strings by searching for line break followed by spaces.\n    const manualIndent = new RegExp(`[\\\\n][${indents}]+`);\n    if (str.match(manualIndent)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.slice(0, indent);\n    const columnText = str.slice(indent).replace('\\r\\n', '\\n');\n    const indentString = ' '.repeat(indent);\n    const zeroWidthSpace = '\\u200B';\n    const breaks = `\\\\s${zeroWidthSpace}`;\n    // Match line end (so empty lines don't collapse),\n    // or as much text as will fit in column, or excess text up to first break.\n    const regex = new RegExp(\n      `\\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,\n      'g',\n    );\n    const lines = columnText.match(regex) || [];\n    return (\n      leadingStr +\n      lines\n        .map((line, i) => {\n          if (line === '\\n') return ''; // preserve empty lines\n          return (i > 0 ? indentString : '') + line.trimEnd();\n        })\n        .join('\\n')\n    );\n  }\n}\n\nexports.Help = Help;\n", "const { InvalidArgumentError } = require('./error.js');\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {*} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {(string | string[])} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    let newImplied = impliedOptionValues;\n    if (typeof impliedOptionValues === 'string') {\n      // string is not documented, but easy mistake and we can do what user probably intended.\n      newImplied = { [impliedOptionValues]: true };\n    }\n    this.implied = Object.assign(this.implied || {}, newImplied);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variable is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @package\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(\n          `Allowed choices are ${this.argChoices.join(', ')}.`,\n        );\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @package\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @package\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach((option) => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {*} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = preset !== undefined ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))\n    shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.DualOptions = DualOptions;\n", "const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/Damerau\u2013Levenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance)\n    return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost, // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map((candidate) => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map((candidate) => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n", "const EventEmitter = require('node:events').EventEmitter;\nconst childProcess = require('node:child_process');\nconst path = require('node:path');\nconst fs = require('node:fs');\nconst process = require('node:process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, DualOptions } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this.registeredArguments = [];\n    this._args = this.registeredArguments; // deprecated old name\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default, env, cli etc\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {(boolean | string)} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () =>\n        process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () =>\n        process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str),\n    };\n\n    this._hidden = false;\n    /** @type {(Option | null | undefined)} */\n    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.\n    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited\n    /** @type {Command} */\n    this._helpCommand = undefined; // lazy initialised, inherited\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._helpOption = sourceCommand._helpOption;\n    this._helpCommand = sourceCommand._helpCommand;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue =\n      sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * @returns {Command[]}\n   * @private\n   */\n\n  _getCommandAndAncestors() {\n    const result = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    for (let command = this; command; command = command.parent) {\n      result.push(command);\n    }\n    return result;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this._registerCommand(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {object} [configuration] - configuration options\n   * @return {(Command | object)} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {object} [configuration] - configuration options\n   * @return {(Command | object)} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {(boolean|string)} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this._registerCommand(cmd);\n    cmd.parent = this;\n    cmd._checkForBrokenPassThrough();\n\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {(Function|*)} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names\n      .trim()\n      .split(/ +/)\n      .forEach((detail) => {\n        this.argument(detail);\n      });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this.registeredArguments.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(\n        `only the last argument can be variadic '${previousArgument.name()}'`,\n      );\n    }\n    if (\n      argument.required &&\n      argument.defaultValue !== undefined &&\n      argument.parseArg === undefined\n    ) {\n      throw new Error(\n        `a default value for a required argument is never used: '${argument.name()}'`,\n      );\n    }\n    this.registeredArguments.push(argument);\n    return this;\n  }\n\n  /**\n   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.\n   *\n   * @example\n   *    program.helpCommand('help [cmd]');\n   *    program.helpCommand('help [cmd]', 'show help');\n   *    program.helpCommand(false); // suppress default help command\n   *    program.helpCommand(true); // add help command even if no subcommands\n   *\n   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added\n   * @param {string} [description] - custom description\n   * @return {Command} `this` command for chaining\n   */\n\n  helpCommand(enableOrNameAndArgs, description) {\n    if (typeof enableOrNameAndArgs === 'boolean') {\n      this._addImplicitHelpCommand = enableOrNameAndArgs;\n      return this;\n    }\n\n    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';\n    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);\n    const helpDescription = description ?? 'display help for command';\n\n    const helpCommand = this.createCommand(helpName);\n    helpCommand.helpOption(false);\n    if (helpArgs) helpCommand.arguments(helpArgs);\n    if (helpDescription) helpCommand.description(helpDescription);\n\n    this._addImplicitHelpCommand = true;\n    this._helpCommand = helpCommand;\n\n    return this;\n  }\n\n  /**\n   * Add prepared custom help command.\n   *\n   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`\n   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only\n   * @return {Command} `this` command for chaining\n   */\n  addHelpCommand(helpCommand, deprecatedDescription) {\n    // If not passed an object, call through to helpCommand for backwards compatibility,\n    // as addHelpCommand was originally used like helpCommand is now.\n    if (typeof helpCommand !== 'object') {\n      this.helpCommand(helpCommand, deprecatedDescription);\n      return this;\n    }\n\n    this._addImplicitHelpCommand = true;\n    this._helpCommand = helpCommand;\n    return this;\n  }\n\n  /**\n   * Lazy create help command.\n   *\n   * @return {(Command|null)}\n   * @package\n   */\n  _getHelpCommand() {\n    const hasImplicitHelpCommand =\n      this._addImplicitHelpCommand ??\n      (this.commands.length &&\n        !this._actionHandler &&\n        !this._findCommand('help'));\n\n    if (hasImplicitHelpCommand) {\n      if (this._helpCommand === undefined) {\n        this.helpCommand(undefined, undefined); // use default name and description\n      }\n      return this._helpCommand;\n    }\n    return null;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this.registeredArguments.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Wrap parseArgs to catch 'commander.invalidArgument'.\n   *\n   * @param {(Option | Argument)} target\n   * @param {string} value\n   * @param {*} previous\n   * @param {string} invalidArgumentMessage\n   * @private\n   */\n\n  _callParseArg(target, value, previous, invalidArgumentMessage) {\n    try {\n      return target.parseArg(value, previous);\n    } catch (err) {\n      if (err.code === 'commander.invalidArgument') {\n        const message = `${invalidArgumentMessage} ${err.message}`;\n        this.error(message, { exitCode: err.exitCode, code: err.code });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Check for option flag conflicts.\n   * Register option if no conflicts found, or throw on conflict.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  _registerOption(option) {\n    const matchingOption =\n      (option.short && this._findOption(option.short)) ||\n      (option.long && this._findOption(option.long));\n    if (matchingOption) {\n      const matchingFlag =\n        option.long && this._findOption(option.long)\n          ? option.long\n          : option.short;\n      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'\n-  already used by option '${matchingOption.flags}'`);\n    }\n\n    this.options.push(option);\n  }\n\n  /**\n   * Check for command name and alias conflicts with existing commands.\n   * Register command if no conflicts found, or throw on conflict.\n   *\n   * @param {Command} command\n   * @private\n   */\n\n  _registerCommand(command) {\n    const knownBy = (cmd) => {\n      return [cmd.name()].concat(cmd.aliases());\n    };\n\n    const alreadyUsed = knownBy(command).find((name) =>\n      this._findCommand(name),\n    );\n    if (alreadyUsed) {\n      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');\n      const newCmd = knownBy(command).join('|');\n      throw new Error(\n        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,\n      );\n    }\n\n    this.commands.push(command);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    this._registerOption(option);\n\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(\n          name,\n          option.defaultValue === undefined ? true : option.defaultValue,\n          'default',\n        );\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        val = this._callParseArg(option, val, oldValue, invalidValueMessage);\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @return {Command} `this` command for chaining\n   * @private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error(\n        'To add an Option object use addOption() instead of option() or requiredOption()',\n      );\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required\n   * option-argument is indicated by `<>` and an optional option-argument by `[]`.\n   *\n   * See the README for more details, and see also addOption() and requiredOption().\n   *\n   * @example\n   * program\n   *     .option('-p, --pepper', 'add pepper')\n   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument\n   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default\n   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {(Function|*)} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, parseArg, defaultValue) {\n    return this._optionEx({}, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n   * Add a required option which must have a value after parsing. This usually means\n   * the option must be specified on the command line. (Otherwise the same as .option().)\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {(Function|*)} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  requiredOption(flags, description, parseArg, defaultValue) {\n    return this._optionEx(\n      { mandatory: true },\n      flags,\n      description,\n      parseArg,\n      defaultValue,\n    );\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.\n   * @return {Command} `this` command for chaining\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.\n   * @return {Command} `this` command for chaining\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.\n   * @return {Command} `this` command for chaining\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {boolean} [positional]\n   * @return {Command} `this` command for chaining\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {boolean} [passThrough] for unknown options.\n   * @return {Command} `this` command for chaining\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    this._checkForBrokenPassThrough();\n    return this;\n  }\n\n  /**\n   * @private\n   */\n\n  _checkForBrokenPassThrough() {\n    if (\n      this.parent &&\n      this._passThroughOptions &&\n      !this.parent._enablePositionalOptions\n    ) {\n      throw new Error(\n        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,\n      );\n    }\n  }\n\n  /**\n   * Whether to store option values as properties on command object,\n   * or store separately (specify false). In both cases the option values can be accessed using .opts().\n   *\n   * @param {boolean} [storeAsProperties=true]\n   * @return {Command} `this` command for chaining\n   */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    if (Object.keys(this._optionValues).length) {\n      throw new Error(\n        'call .storeOptionsAsProperties() before setting option values',\n      );\n    }\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    return this.setOptionValueWithSource(key, value, undefined);\n  }\n\n  /**\n   * Store option value and where the value came from.\n   *\n   * @param {string} key\n   * @param {object} value\n   * @param {string} source - expected values are default/config/env/cli/implied\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValueWithSource(key, value, source) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n   * Get source of option value.\n   * Expected values are default | config | env | cli | implied\n   *\n   * @param {string} key\n   * @return {string}\n   */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n   * Get source of option value. See also .optsWithGlobals().\n   * Expected values are default | config | env | cli | implied\n   *\n   * @param {string} key\n   * @return {string}\n   */\n\n  getOptionValueSourceWithGlobals(key) {\n    // global overwrites local, like optsWithGlobals\n    let source;\n    this._getCommandAndAncestors().forEach((cmd) => {\n      if (cmd.getOptionValueSource(key) !== undefined) {\n        source = cmd.getOptionValueSource(key);\n      }\n    });\n    return source;\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // auto-detect argument conventions if nothing supplied\n    if (argv === undefined && parseOptions.from === undefined) {\n      if (process.versions?.electron) {\n        parseOptions.from = 'electron';\n      }\n      // check node specific options for scenarios where user CLI args follow executable without scriptname\n      const execArgv = process.execArgv ?? [];\n      if (\n        execArgv.includes('-e') ||\n        execArgv.includes('--eval') ||\n        execArgv.includes('-p') ||\n        execArgv.includes('--print')\n      ) {\n        parseOptions.from = 'eval'; // internal usage, not documented\n      }\n    }\n\n    // default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n    }\n    this.rawArgs = argv.slice();\n\n    // extract the user args and scriptPath\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: because defaultApp is an unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      case 'eval':\n        userArgs = argv.slice(1);\n        break;\n      default:\n        throw new Error(\n          `unexpected parse option { from: '${parseOptions.from}' }`,\n        );\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath)\n      this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async.\n   *\n   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!\n   *\n   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:\n   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that\n   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged\n   * - `'user'`: just user arguments\n   *\n   * @example\n   * program.parse(); // parse process.argv and auto-detect electron and special node flags\n   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!\n   *\n   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:\n   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that\n   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged\n   * - `'user'`: just user arguments\n   *\n   * @example\n   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags\n   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find((ext) =>\n        fs.existsSync(`${localBin}${ext}`),\n      );\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile =\n      subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(\n        path.dirname(resolvedScriptPath),\n        executableDir,\n      );\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(\n          this._scriptPath,\n          path.extname(this._scriptPath),\n        );\n        if (legacyName !== this._name) {\n          localFile = findFile(\n            executableDir,\n            `${legacyName}-${subcommand._name}`,\n          );\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) {\n      // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            // @ts-ignore because signals not typed to known strings\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    const exitCallback = this._exitCallback;\n    proc.on('close', (code) => {\n      code = code ?? 1; // code is null if spawned process terminated due to a signal\n      if (!exitCallback) {\n        process.exit(code);\n      } else {\n        exitCallback(\n          new CommanderError(\n            code,\n            'commander.executeSubCommandAsync',\n            '(close)',\n          ),\n        );\n      }\n    });\n    proc.on('error', (err) => {\n      // @ts-ignore: because err.code is an unknown property\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n        // @ts-ignore: because err.code is an unknown property\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(\n          1,\n          'commander.executeSubCommandAsync',\n          '(error)',\n        );\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    let promiseChain;\n    promiseChain = this._chainOrCallSubCommandHook(\n      promiseChain,\n      subCommand,\n      'preSubcommand',\n    );\n    promiseChain = this._chainOrCall(promiseChain, () => {\n      if (subCommand._executableHandler) {\n        this._executeSubCommand(subCommand, operands.concat(unknown));\n      } else {\n        return subCommand._parseCommand(operands, unknown);\n      }\n    });\n    return promiseChain;\n  }\n\n  /**\n   * Invoke help directly if possible, or dispatch if necessary.\n   * e.g. help foo\n   *\n   * @private\n   */\n\n  _dispatchHelpCommand(subcommandName) {\n    if (!subcommandName) {\n      this.help();\n    }\n    const subCommand = this._findCommand(subcommandName);\n    if (subCommand && !subCommand._executableHandler) {\n      subCommand.help();\n    }\n\n    // Fallback to parsing the help flag to invoke the help.\n    return this._dispatchSubcommand(\n      subcommandName,\n      [],\n      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],\n    );\n  }\n\n  /**\n   * Check this.args against expected this.registeredArguments.\n   *\n   * @private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this.registeredArguments.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (\n      this.registeredArguments.length > 0 &&\n      this.registeredArguments[this.registeredArguments.length - 1].variadic\n    ) {\n      return;\n    }\n    if (this.args.length > this.registeredArguments.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this.registeredArguments and save as this.processedArgs!\n   *\n   * @private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;\n        parsedValue = this._callParseArg(\n          argument,\n          value,\n          previous,\n          invalidValueMessage,\n        );\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this.registeredArguments.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {Function} fn\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {string} event\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    this._getCommandAndAncestors()\n      .reverse()\n      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach((hookedCommand) => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {Command} subCommand\n   * @param {string} event\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCallSubCommandHook(promise, subCommand, event) {\n    let result = promise;\n    if (this._lifeCycleHooks[event] !== undefined) {\n      this._lifeCycleHooks[event].forEach((hook) => {\n        result = this._chainOrCall(result, () => {\n          return hook(this, subCommand);\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (\n      this._getHelpCommand() &&\n      operands[0] === this._getHelpCommand().name()\n    ) {\n      return this._dispatchHelpCommand(operands[1]);\n    }\n    if (this._defaultCommandName) {\n      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(\n        this._defaultCommandName,\n        operands,\n        unknown,\n      );\n    }\n    if (\n      this.commands.length &&\n      this.args.length === 0 &&\n      !this._actionHandler &&\n      !this._defaultCommandName\n    ) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    this._outputHelpIfRequested(parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let promiseChain;\n      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');\n      promiseChain = this._chainOrCall(promiseChain, () =>\n        this._actionHandler(this.processedArgs),\n      );\n      if (this.parent) {\n        promiseChain = this._chainOrCall(promiseChain, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');\n      return promiseChain;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) {\n        // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @private\n   * @return {Command | undefined}\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(\n      (cmd) => cmd._name === name || cmd._aliases.includes(name),\n    );\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @package\n   */\n\n  _findOption(arg) {\n    return this.options.find((option) => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd.options.forEach((anOption) => {\n        if (\n          anOption.mandatory &&\n          cmd.getOptionValue(anOption.attributeName()) === undefined\n        ) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter((option) => {\n      const optionKey = option.attributeName();\n      if (this.getOptionValue(optionKey) === undefined) {\n        return false;\n      }\n      return this.getOptionValueSource(optionKey) !== 'default';\n    });\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0,\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName()),\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd._checkForConflictingLocalOptions();\n    });\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {string[]} argv\n   * @return {{operands: string[], unknown: string[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else {\n            // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (\n            option.required ||\n            (option.optional && this._combineFlagAndOptionalValue)\n          ) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if (\n        (this._enablePositionalOptions || this._passThroughOptions) &&\n        operands.length === 0 &&\n        unknown.length === 0\n      ) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (\n          this._getHelpCommand() &&\n          arg === this._getHelpCommand().name()\n        ) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] =\n          key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return this._getCommandAndAncestors().reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {},\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(\n      `${message}\\n`,\n      this._outputConfiguration.writeErr,\n    );\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (\n          this.getOptionValue(optionKey) === undefined ||\n          ['default', 'config', 'env'].includes(\n            this.getOptionValueSource(optionKey),\n          )\n        ) {\n          if (option.required || option.optional) {\n            // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else {\n            // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = (optionKey) => {\n      return (\n        this.getOptionValue(optionKey) !== undefined &&\n        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))\n      );\n    };\n    this.options\n      .filter(\n        (option) =>\n          option.implied !== undefined &&\n          hasCustomOptionValue(option.attributeName()) &&\n          dualHelper.valueFromOption(\n            this.getOptionValue(option.attributeName()),\n            option,\n          ),\n      )\n      .forEach((option) => {\n        Object.keys(option.implied)\n          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))\n          .forEach((impliedKey) => {\n            this.setOptionValueWithSource(\n              impliedKey,\n              option.implied[impliedKey],\n              'implied',\n            );\n          });\n      });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(\n        (target) => target.negate && optionKey === target.attributeName(),\n      );\n      const positiveOption = this.options.find(\n        (target) => !target.negate && optionKey === target.attributeName(),\n      );\n      if (\n        negativeOption &&\n        ((negativeOption.presetArg === undefined && optionValue === false) ||\n          (negativeOption.presetArg !== undefined &&\n            optionValue === negativeOption.presetArg))\n      ) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let command = this;\n      do {\n        const moreFlags = command\n          .createHelp()\n          .visibleOptions(command)\n          .filter((option) => option.long)\n          .map((option) => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this.registeredArguments.length;\n    const s = expected === 1 ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp()\n        .visibleCommands(this)\n        .forEach((command) => {\n          candidateNames.push(command.name());\n          // just visible alias\n          if (command.alias()) candidateNames.push(command.alias());\n        });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Get or set the program version.\n   *\n   * This method auto-registers the \"-V, --version\" option which will print the version number.\n   *\n   * You can optionally supply the flags and description to override the defaults.\n   *\n   * @param {string} [str]\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this._registerOption(versionOption);\n\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {object} [argsDescription]\n   * @return {(string|Command)}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined)\n      return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {(string|Command)}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let command = this;\n    if (\n      this.commands.length !== 0 &&\n      this.commands[this.commands.length - 1]._executableHandler\n    ) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name)\n      throw new Error(\"Command alias can't be the same as its name\");\n    const matchingCommand = this.parent?._findCommand(alias);\n    if (matchingCommand) {\n      // c.f. _registerCommand\n      const existingCmd = [matchingCommand.name()]\n        .concat(matchingCommand.aliases())\n        .join('|');\n      throw new Error(\n        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,\n      );\n    }\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {(string[]|Command)}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this.registeredArguments.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return []\n        .concat(\n          this.options.length || this._helpOption !== null ? '[options]' : [],\n          this.commands.length ? '[command]' : [],\n          this.registeredArguments.length ? args : [],\n        )\n        .join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {(string|null|Command)}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth =\n        contextOptions && contextOptions.error\n          ? this._outputConfiguration.getErrHelpWidth()\n          : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    this._getCommandAndAncestors()\n      .reverse()\n      .forEach((command) => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (\n        typeof helpInformation !== 'string' &&\n        !Buffer.isBuffer(helpInformation)\n      ) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    if (this._getHelpOption()?.long) {\n      this.emit(this._getHelpOption().long); // deprecated\n    }\n    this.emit('afterHelp', context);\n    this._getCommandAndAncestors().forEach((command) =>\n      command.emit('afterAllHelp', context),\n    );\n  }\n\n  /**\n   * You can pass in flags and a description to customise the built-in help option.\n   * Pass in false to disable the built-in help option.\n   *\n   * @example\n   * program.helpOption('-?, --help' 'show help'); // customise\n   * program.helpOption(false); // disable\n   *\n   * @param {(string | boolean)} flags\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    // Support disabling built-in help option.\n    if (typeof flags === 'boolean') {\n      if (flags) {\n        this._helpOption = this._helpOption ?? undefined; // preserve existing option\n      } else {\n        this._helpOption = null; // disable\n      }\n      return this;\n    }\n\n    // Customise flags and description.\n    flags = flags ?? '-h, --help';\n    description = description ?? 'display help for command';\n    this._helpOption = this.createOption(flags, description);\n\n    return this;\n  }\n\n  /**\n   * Lazy create help option.\n   * Returns null if has been disabled with .helpOption(false).\n   *\n   * @returns {(Option | null)} the help option\n   * @package\n   */\n  _getHelpOption() {\n    // Lazy create help option on demand.\n    if (this._helpOption === undefined) {\n      this.helpOption(undefined, undefined);\n    }\n    return this._helpOption;\n  }\n\n  /**\n   * Supply your own option to use for the built-in help option.\n   * This is an alternative to using helpOption() to customise the flags and description etc.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addHelpOption(option) {\n    this._helpOption = option;\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (\n      exitCode === 0 &&\n      contextOptions &&\n      typeof contextOptions !== 'function' &&\n      contextOptions.error\n    ) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {(string | Function)} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Output help information if help flags specified\n   *\n   * @param {Array} args - array of options to search for help flags\n   * @private\n   */\n\n  _outputHelpIfRequested(args) {\n    const helpOption = this._getHelpOption();\n    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));\n    if (helpRequested) {\n      this.outputHelp();\n      // (Do not have all displayed text available so only passing placeholder.)\n      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n    }\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if (\n      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null\n    ) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if (\n      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null\n    ) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\nexports.Command = Command;\n", "const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\nexports.program = new Command();\n\nexports.createCommand = (name) => new Command(name);\nexports.createOption = (flags, description) => new Option(flags, description);\nexports.createArgument = (name, description) => new Argument(name, description);\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.Argument = Argument;\nexports.Help = Help;\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\n", "'use strict';\n\n// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\n\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n\n// Make a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n// The key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n//\n// indents = {\n//    t3: [1, 0],\n//    t4: [1, 5],\n//    s5: [1, 0],\n//   s12: [1, 0],\n// }\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n\tconst indents = new Map();\n\n\t// Remember the size of previous line's indentation\n\tlet previousSize = 0;\n\tlet previousIndentType;\n\n\t// Indents key (ident type + size of the indents/unindents)\n\tlet key;\n\n\tfor (const line of string.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// Ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tlet indentType;\n\t\tlet weight;\n\t\tlet entry;\n\t\tconst matches = line.match(INDENT_REGEX);\n\n\t\tif (matches === null) {\n\t\t\tpreviousSize = 0;\n\t\t\tpreviousIndentType = '';\n\t\t} else {\n\t\t\tindent = matches[0].length;\n\n\t\t\tif (matches[1]) {\n\t\t\t\tindentType = INDENT_TYPE_SPACE;\n\t\t\t} else {\n\t\t\t\tindentType = INDENT_TYPE_TAB;\n\t\t\t}\n\n\t\t\t// Ignore single space unless it's the only indent detected to prevent common false positives\n\t\t\tif (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (indentType !== previousIndentType) {\n\t\t\t\tpreviousSize = 0;\n\t\t\t}\n\n\t\t\tpreviousIndentType = indentType;\n\n\t\t\tweight = 0;\n\n\t\t\tconst indentDifference = indent - previousSize;\n\t\t\tpreviousSize = indent;\n\n\t\t\t// Previous line have same indent?\n\t\t\tif (indentDifference === 0) {\n\t\t\t\tweight++;\n\t\t\t\t// We use the key from previous loop\n\t\t\t} else {\n\t\t\t\tconst absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n\t\t\t\tkey = encodeIndentsKey(indentType, absoluteIndentDifference);\n\t\t\t}\n\n\t\t\t// Update the stats\n\t\t\tentry = indents.get(key);\n\n\t\t\tif (entry === undefined) {\n\t\t\t\tentry = [1, 0]; // Init\n\t\t\t} else {\n\t\t\t\tentry = [++entry[0], entry[1] + weight];\n\t\t\t}\n\n\t\t\tindents.set(key, entry);\n\t\t}\n\t}\n\n\treturn indents;\n}\n\n// Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\nfunction encodeIndentsKey(indentType, indentAmount) {\n\tconst typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n\treturn typeCharacter + String(indentAmount);\n}\n\n// Extract the indent type and amount from a key of the indents Map.\nfunction decodeIndentsKey(indentsKey) {\n\tconst keyHasTypeSpace = indentsKey[0] === 's';\n\tconst type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\tconst amount = Number(indentsKey.slice(1));\n\n\treturn {type, amount};\n}\n\n// Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\nfunction getMostUsedKey(indents) {\n\tlet result;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const [key, [usedCount, weight]] of indents) {\n\t\tif (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {\n\t\t\tmaxUsed = usedCount;\n\t\t\tmaxWeight = weight;\n\t\t\tresult = key;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction makeIndentString(type, amount) {\n\tconst indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n\treturn indentCharacter.repeat(amount);\n}\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n\t// If no indents are identified, run again and include all indents for comprehensive detection\n\tlet indents = makeIndentsMap(string, true);\n\tif (indents.size === 0) {\n\t\tindents = makeIndentsMap(string, false);\n\t}\n\n\tconst keyOfMostUsedIndent = getMostUsedKey(indents);\n\n\tlet type;\n\tlet amount = 0;\n\tlet indent = '';\n\n\tif (keyOfMostUsedIndent !== undefined) {\n\t\t({type, amount} = decodeIndentsKey(keyOfMostUsedIndent));\n\t\tindent = makeIndentString(type, amount);\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent\n\t};\n};\n", "// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n", "const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n", "const {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n", "// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n", "const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n", "const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (!identifier && identifierBase === false) {\n          throw new Error('invalid increment argument: identifier is empty')\n        }\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n", "const SemVer = require('../classes/semver')\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n", "const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n", "const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n", "const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n", "const parse = require('./parse.js')\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // Otherwise it can be determined by checking the high version\n\n    if (highVersion.patch) {\n      // anything higher than a patch bump would result in the wrong version\n      return 'patch'\n    }\n\n    if (highVersion.minor) {\n      // anything higher than a minor bump would result in the wrong version\n      return 'minor'\n    }\n\n    // bumping major/minor/patch all have same result\n    return 'major'\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n", "const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n", "const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n", "const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n", "const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n", "const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n", "const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n", "const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n", "const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n", "const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n", "const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n", "const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n", "const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n", "const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n", "const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n", "const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n", "const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n", "const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n", "const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n", "class LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n", "const SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = require('../internal/lrucache')\nconst cache = new LRU()\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n", "const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { safeRe: re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n", "const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n", "const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n", "const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n", "const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n", "const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n", "const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n", "const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n", "// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n", "const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n", "const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n", "// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n", "const Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n", "// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nconst constants = require('./internal/constants')\nconst SemVer = require('./classes/semver')\nconst identifiers = require('./internal/identifiers')\nconst parse = require('./functions/parse')\nconst valid = require('./functions/valid')\nconst clean = require('./functions/clean')\nconst inc = require('./functions/inc')\nconst diff = require('./functions/diff')\nconst major = require('./functions/major')\nconst minor = require('./functions/minor')\nconst patch = require('./functions/patch')\nconst prerelease = require('./functions/prerelease')\nconst compare = require('./functions/compare')\nconst rcompare = require('./functions/rcompare')\nconst compareLoose = require('./functions/compare-loose')\nconst compareBuild = require('./functions/compare-build')\nconst sort = require('./functions/sort')\nconst rsort = require('./functions/rsort')\nconst gt = require('./functions/gt')\nconst lt = require('./functions/lt')\nconst eq = require('./functions/eq')\nconst neq = require('./functions/neq')\nconst gte = require('./functions/gte')\nconst lte = require('./functions/lte')\nconst cmp = require('./functions/cmp')\nconst coerce = require('./functions/coerce')\nconst Comparator = require('./classes/comparator')\nconst Range = require('./classes/range')\nconst satisfies = require('./functions/satisfies')\nconst toComparators = require('./ranges/to-comparators')\nconst maxSatisfying = require('./ranges/max-satisfying')\nconst minSatisfying = require('./ranges/min-satisfying')\nconst minVersion = require('./ranges/min-version')\nconst validRange = require('./ranges/valid')\nconst outside = require('./ranges/outside')\nconst gtr = require('./ranges/gtr')\nconst ltr = require('./ranges/ltr')\nconst intersects = require('./ranges/intersects')\nconst simplifyRange = require('./ranges/simplify')\nconst subset = require('./ranges/subset')\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n", "'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  const node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      const ele = arr[i];\n\n      if (Array.isArray(ele)) {\n        flat(ele);\n        continue;\n      }\n\n      if (ele !== undefined) {\n        result.push(ele);\n      }\n    }\n    return result;\n  };\n\n  flat(args);\n  return result;\n};\n", "'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  const stringify = (node, parent = {}) => {\n    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n", "/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n", "/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n", "/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options, maxLen) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options, maxLen)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  const walk = (node, parent = {}) => {\n    const invalidBlock = utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    const invalid = invalidBlock === true || invalidNode === true;\n    const prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      console.log('node.isClose', prefix, node.value);\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n", "'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  const result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (const item of queue) {\n    if (Array.isArray(item)) {\n      for (const value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\n\n  const walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    const enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      const child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n", "'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 10000,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n", "'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  const opts = options || {};\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  const ast = { type: 'root', input, nodes: [] };\n  const stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  const length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      const open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      const brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      const type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        const open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      const siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        const before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      const parent = stack[stack.length - 1];\n      const index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (const pattern of input) {\n      const result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n", "'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n", "'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n", "'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n", "'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n", "'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n", "'use strict';\n\nmodule.exports = require('./lib/picomatch');\n", "'use strict';\n\nconst util = require('util');\nconst braces = require('braces');\nconst picomatch = require('picomatch');\nconst utils = require('picomatch/lib/utils');\n\nconst isEmptyString = v => v === '' || v === './';\nconst hasBraces = v => {\n  const index = v.indexOf('{');\n  return index > -1 && v.indexOf('}', index) > -1;\n};\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));\n\n  for (let item of items) {\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !hasBraces(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\n// exposed for tests\nmicromatch.hasBraces = hasBraces;\nmodule.exports = micromatch;\n", "module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\n", "module.exports = (typeof process !== 'undefined' && typeof process.nextTick === 'function')\n  ? process.nextTick.bind(process)\n  : require('./queue-microtask')\n", "module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n", "const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n", "function isBuffer (value) {\n  return Buffer.isBuffer(value) || value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  return Buffer.isEncoding(encoding)\n}\n\nfunction alloc (size, fill, encoding) {\n  return Buffer.alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  return Buffer.allocUnsafe(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return Buffer.allocUnsafeSlow(size)\n}\n\nfunction byteLength (string, encoding) {\n  return Buffer.byteLength(string, encoding)\n}\n\nfunction compare (a, b) {\n  return Buffer.compare(a, b)\n}\n\nfunction concat (buffers, totalLength) {\n  return Buffer.concat(buffers, totalLength)\n}\n\nfunction copy (source, target, targetStart, start, end) {\n  return toBuffer(source).copy(target, targetStart, start, end)\n}\n\nfunction equals (a, b) {\n  return toBuffer(a).equals(b)\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  return toBuffer(buffer).fill(value, offset, end, encoding)\n}\n\nfunction from (value, encodingOrOffset, length) {\n  return Buffer.from(value, encodingOrOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).includes(value, byteOffset, encoding)\n}\n\nfunction indexOf (buffer, value, byfeOffset, encoding) {\n  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)\n}\n\nfunction swap16 (buffer) {\n  return toBuffer(buffer).swap16()\n}\n\nfunction swap32 (buffer) {\n  return toBuffer(buffer).swap32()\n}\n\nfunction swap64 (buffer) {\n  return toBuffer(buffer).swap64()\n}\n\nfunction toBuffer (buffer) {\n  if (Buffer.isBuffer(buffer)) return buffer\n  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\nfunction toString (buffer, encoding, start, end) {\n  return toBuffer(buffer).toString(encoding, start, end)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  return toBuffer(buffer).write(string, offset, length, encoding)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleLE(value, offset)\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  return toBuffer(buffer).writeFloatLE(value, offset)\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32LE(value, offset)\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  return toBuffer(buffer).writeInt32LE(value, offset)\n}\n\nfunction readDoubleLE (buffer, offset) {\n  return toBuffer(buffer).readDoubleLE(offset)\n}\n\nfunction readFloatLE (buffer, offset) {\n  return toBuffer(buffer).readFloatLE(offset)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  return toBuffer(buffer).readUInt32LE(offset)\n}\n\nfunction readInt32LE (buffer, offset) {\n  return toBuffer(buffer).readInt32LE(offset)\n}\n\nfunction writeDoubleBE (buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleBE(value, offset)\n}\n\nfunction writeFloatBE (buffer, value, offset) {\n  return toBuffer(buffer).writeFloatBE(value, offset)\n}\n\nfunction writeUInt32BE (buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32BE(value, offset)\n}\n\nfunction writeInt32BE (buffer, value, offset) {\n  return toBuffer(buffer).writeInt32BE(value, offset)\n}\n\nfunction readDoubleBE (buffer, offset) {\n  return toBuffer(buffer).readDoubleBE(offset)\n}\n\nfunction readFloatBE (buffer, offset) {\n  return toBuffer(buffer).readFloatBE(offset)\n}\n\nfunction readUInt32BE (buffer, offset) {\n  return toBuffer(buffer).readUInt32BE(offset)\n}\n\nfunction readInt32BE (buffer, offset) {\n  return toBuffer(buffer).readInt32BE(offset)\n}\n\nmodule.exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE,\n  writeDoubleBE,\n  writeFloatBE,\n  writeUInt32BE,\n  writeInt32BE,\n  readDoubleBE,\n  readFloatBE,\n  readUInt32BE,\n  readInt32BE\n\n}\n", "const b4a = require('b4a')\n\nmodule.exports = class PassThroughDecoder {\n  constructor (encoding) {\n    this.encoding = encoding\n  }\n\n  get remaining () {\n    return 0\n  }\n\n  decode (tail) {\n    return b4a.toString(tail, this.encoding)\n  }\n\n  flush () {\n    return ''\n  }\n}\n", "const b4a = require('b4a')\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor () {\n    this.codePoint = 0\n    this.bytesSeen = 0\n    this.bytesNeeded = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n  }\n\n  get remaining () {\n    return this.bytesSeen\n  }\n\n  decode (data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true\n\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f\n      }\n\n      if (isBoundary) return b4a.toString(data, 'utf8')\n    }\n\n    let result = ''\n\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i]\n\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte)\n        } else {\n          this.bytesSeen = 1\n\n          if (byte >= 0xc2 && byte <= 0xdf) {\n            this.bytesNeeded = 2\n            this.codePoint = byte & 0x1f\n          } else if (byte >= 0xe0 && byte <= 0xef) {\n            if (byte === 0xe0) this.lowerBoundary = 0xa0\n            else if (byte === 0xed) this.upperBoundary = 0x9f\n            this.bytesNeeded = 3\n            this.codePoint = byte & 0xf\n          } else if (byte >= 0xf0 && byte <= 0xf4) {\n            if (byte === 0xf0) this.lowerBoundary = 0x90\n            if (byte === 0xf4) this.upperBoundary = 0x8f\n            this.bytesNeeded = 4\n            this.codePoint = byte & 0x7\n          } else {\n            result += '\\ufffd'\n          }\n        }\n\n        continue\n      }\n\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0\n        this.bytesNeeded = 0\n        this.bytesSeen = 0\n        this.lowerBoundary = 0x80\n        this.upperBoundary = 0xbf\n\n        result += '\\ufffd'\n\n        continue\n      }\n\n      this.lowerBoundary = 0x80\n      this.upperBoundary = 0xbf\n\n      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)\n      this.bytesSeen++\n\n      if (this.bytesSeen !== this.bytesNeeded) continue\n\n      result += String.fromCodePoint(this.codePoint)\n\n      this.codePoint = 0\n      this.bytesNeeded = 0\n      this.bytesSeen = 0\n    }\n\n    return result\n  }\n\n  flush () {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : ''\n\n    this.codePoint = 0\n    this.bytesNeeded = 0\n    this.bytesSeen = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n\n    return result\n  }\n}\n", "const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n", "const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n", "const b4a = require('b4a')\n\nconst ZEROS = '0000000000000000000'\nconst SEVENS = '7777777777777777777'\nconst ZERO_OFFSET = '0'.charCodeAt(0)\nconst USTAR_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]) // ustar\\x00\nconst USTAR_VER = b4a.from([ZERO_OFFSET, ZERO_OFFSET])\nconst GNU_MAGIC = b4a.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]) // ustar\\x20\nconst GNU_VER = b4a.from([0x20, 0x00])\nconst MASK = 0o7777\nconst MAGIC_OFFSET = 257\nconst VERSION_OFFSET = 263\n\nexports.decodeLongPath = function decodeLongPath (buf, encoding) {\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.encodePax = function encodePax (opts) { // TODO: encode more stuff in pax\n  let result = ''\n  if (opts.name) result += addLength(' path=' + opts.name + '\\n')\n  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\\n')\n  const pax = opts.pax\n  if (pax) {\n    for (const key in pax) {\n      result += addLength(' ' + key + '=' + pax[key] + '\\n')\n    }\n  }\n  return b4a.from(result)\n}\n\nexports.decodePax = function decodePax (buf) {\n  const result = {}\n\n  while (buf.length) {\n    let i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n    const len = parseInt(b4a.toString(buf.subarray(0, i)), 10)\n    if (!len) return result\n\n    const b = b4a.toString(buf.subarray(i + 1, len - 1))\n    const keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.subarray(len)\n  }\n\n  return result\n}\n\nexports.encode = function encode (opts) {\n  const buf = b4a.alloc(512)\n  let name = opts.name\n  let prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'\n  if (b4a.byteLength(name) !== name.length) return null // utf-8\n\n  while (b4a.byteLength(name) > 100) {\n    const i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i + 1)\n  }\n\n  if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null\n  if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null\n\n  b4a.write(buf, name)\n  b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100)\n  b4a.write(buf, encodeOct(opts.uid, 6), 108)\n  b4a.write(buf, encodeOct(opts.gid, 6), 116)\n  encodeSize(opts.size, buf, 124)\n  b4a.write(buf, encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) b4a.write(buf, opts.linkname, 157)\n\n  b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET)\n  b4a.copy(USTAR_VER, buf, VERSION_OFFSET)\n  if (opts.uname) b4a.write(buf, opts.uname, 265)\n  if (opts.gname) b4a.write(buf, opts.gname, 297)\n  b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329)\n  b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) b4a.write(buf, prefix, 345)\n\n  b4a.write(buf, encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function decode (buf, filenameEncoding, allowUnknownFormat) {\n  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  let name = decodeStr(buf, 0, 100, filenameEncoding)\n  const mode = decodeOct(buf, 100, 8)\n  const uid = decodeOct(buf, 108, 8)\n  const gid = decodeOct(buf, 116, 8)\n  const size = decodeOct(buf, 124, 12)\n  const mtime = decodeOct(buf, 136, 12)\n  const type = toType(typeflag)\n  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  const uname = decodeStr(buf, 265, 32)\n  const gname = decodeStr(buf, 297, 32)\n  const devmajor = decodeOct(buf, 329, 8)\n  const devminor = decodeOct(buf, 337, 8)\n\n  const c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (isUSTAR(buf)) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (isGNU(buf)) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    if (!allowUnknownFormat) {\n      throw new Error('Invalid tar header: unknown format.')\n    }\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: new Date(1000 * mtime),\n    type,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor,\n    pax: null\n  }\n}\n\nfunction isUSTAR (buf) {\n  return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))\n}\n\nfunction isGNU (buf) {\n  return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&\n    b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))\n}\n\nfunction clamp (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nfunction toType (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nfunction toTypeflag (flag) {\n  switch (flag) {\n    case 'file':\n      return 0\n    case 'link':\n      return 1\n    case 'symlink':\n      return 2\n    case 'character-device':\n      return 3\n    case 'block-device':\n      return 4\n    case 'directory':\n      return 5\n    case 'fifo':\n      return 6\n    case 'contiguous-file':\n      return 7\n    case 'pax-header':\n      return 72\n  }\n\n  return 0\n}\n\nfunction indexOf (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nfunction cksum (block) {\n  let sum = 8 * 32\n  for (let i = 0; i < 148; i++) sum += block[i]\n  for (let j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\nfunction encodeOct (val, n) {\n  val = val.toString(8)\n  if (val.length > n) return SEVENS.slice(0, n) + ' '\n  return ZEROS.slice(0, n - val.length) + val + ' '\n}\n\nfunction encodeSizeBin (num, buf, off) {\n  buf[off] = 0x80\n  for (let i = 11; i > 0; i--) {\n    buf[off + i] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nfunction encodeSize (num, buf, off) {\n  if (num.toString(8).length > 11) {\n    encodeSizeBin(num, buf, off)\n  } else {\n    b4a.write(buf, encodeOct(num, 11), off)\n  }\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  let positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  const tuple = []\n  let i\n  for (i = buf.length - 1; i > 0; i--) {\n    const byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xFF - byte)\n  }\n\n  let sum = 0\n  const l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nfunction decodeOct (val, offset, length) {\n  val = val.subarray(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val[offset] === 32) offset++\n    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val[offset] === 0) offset++\n    if (end === offset) return 0\n    return parseInt(b4a.toString(val.subarray(offset, end)), 8)\n  }\n}\n\nfunction decodeStr (val, offset, length, encoding) {\n  return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)\n}\n\nfunction addLength (str) {\n  const len = b4a.byteLength(str)\n  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits >= Math.pow(10, digits)) digits++\n\n  return (len + digits) + str\n}\n", "const { Writable, Readable, getStreamError } = require('streamx')\nconst FIFO = require('fast-fifo')\nconst b4a = require('b4a')\nconst headers = require('./headers')\n\nconst EMPTY = b4a.alloc(0)\n\nclass BufferList {\n  constructor () {\n    this.buffered = 0\n    this.shifted = 0\n    this.queue = new FIFO()\n\n    this._offset = 0\n  }\n\n  push (buffer) {\n    this.buffered += buffer.byteLength\n    this.queue.push(buffer)\n  }\n\n  shiftFirst (size) {\n    return this._buffered === 0 ? null : this._next(size)\n  }\n\n  shift (size) {\n    if (size > this.buffered) return null\n    if (size === 0) return EMPTY\n\n    let chunk = this._next(size)\n\n    if (size === chunk.byteLength) return chunk // likely case\n\n    const chunks = [chunk]\n\n    while ((size -= chunk.byteLength) > 0) {\n      chunk = this._next(size)\n      chunks.push(chunk)\n    }\n\n    return b4a.concat(chunks)\n  }\n\n  _next (size) {\n    const buf = this.queue.peek()\n    const rem = buf.byteLength - this._offset\n\n    if (size >= rem) {\n      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf\n      this.queue.shift()\n      this._offset = 0\n      this.buffered -= rem\n      this.shifted += rem\n      return sub\n    }\n\n    this.buffered -= size\n    this.shifted += size\n\n    return buf.subarray(this._offset, (this._offset += size))\n  }\n}\n\nclass Source extends Readable {\n  constructor (self, header, offset) {\n    super()\n\n    this.header = header\n    this.offset = offset\n\n    this._parent = self\n  }\n\n  _read (cb) {\n    if (this.header.size === 0) {\n      this.push(null)\n    }\n    if (this._parent._stream === this) {\n      this._parent._update()\n    }\n    cb(null)\n  }\n\n  _predestroy () {\n    this._parent.destroy(getStreamError(this))\n  }\n\n  _detach () {\n    if (this._parent._stream === this) {\n      this._parent._stream = null\n      this._parent._missing = overflow(this.header.size)\n      this._parent._update()\n    }\n  }\n\n  _destroy (cb) {\n    this._detach()\n    cb(null)\n  }\n}\n\nclass Extract extends Writable {\n  constructor (opts) {\n    super(opts)\n\n    if (!opts) opts = {}\n\n    this._buffer = new BufferList()\n    this._offset = 0\n    this._header = null\n    this._stream = null\n    this._missing = 0\n    this._longHeader = false\n    this._callback = noop\n    this._locked = false\n    this._finished = false\n    this._pax = null\n    this._paxGlobal = null\n    this._gnuLongPath = null\n    this._gnuLongLinkPath = null\n    this._filenameEncoding = opts.filenameEncoding || 'utf-8'\n    this._allowUnknownFormat = !!opts.allowUnknownFormat\n    this._unlockBound = this._unlock.bind(this)\n  }\n\n  _unlock (err) {\n    this._locked = false\n\n    if (err) {\n      this.destroy(err)\n      this._continueWrite(err)\n      return\n    }\n\n    this._update()\n  }\n\n  _consumeHeader () {\n    if (this._locked) return false\n\n    this._offset = this._buffer.shifted\n\n    try {\n      this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    if (!this._header) return true\n\n    switch (this._header.type) {\n      case 'gnu-long-path':\n      case 'gnu-long-link-path':\n      case 'pax-global-header':\n      case 'pax-header':\n        this._longHeader = true\n        this._missing = this._header.size\n        return true\n    }\n\n    this._locked = true\n    this._applyLongHeaders()\n\n    if (this._header.size === 0 || this._header.type === 'directory') {\n      this.emit('entry', this._header, this._createStream(), this._unlockBound)\n      return true\n    }\n\n    this._stream = this._createStream()\n    this._missing = this._header.size\n\n    this.emit('entry', this._header, this._stream, this._unlockBound)\n    return true\n  }\n\n  _applyLongHeaders () {\n    if (this._gnuLongPath) {\n      this._header.name = this._gnuLongPath\n      this._gnuLongPath = null\n    }\n\n    if (this._gnuLongLinkPath) {\n      this._header.linkname = this._gnuLongLinkPath\n      this._gnuLongLinkPath = null\n    }\n\n    if (this._pax) {\n      if (this._pax.path) this._header.name = this._pax.path\n      if (this._pax.linkpath) this._header.linkname = this._pax.linkpath\n      if (this._pax.size) this._header.size = parseInt(this._pax.size, 10)\n      this._header.pax = this._pax\n      this._pax = null\n    }\n  }\n\n  _decodeLongHeader (buf) {\n    switch (this._header.type) {\n      case 'gnu-long-path':\n        this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'gnu-long-link-path':\n        this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding)\n        break\n      case 'pax-global-header':\n        this._paxGlobal = headers.decodePax(buf)\n        break\n      case 'pax-header':\n        this._pax = this._paxGlobal === null\n          ? headers.decodePax(buf)\n          : Object.assign({}, this._paxGlobal, headers.decodePax(buf))\n        break\n    }\n  }\n\n  _consumeLongHeader () {\n    this._longHeader = false\n    this._missing = overflow(this._header.size)\n\n    const buf = this._buffer.shift(this._header.size)\n\n    try {\n      this._decodeLongHeader(buf)\n    } catch (err) {\n      this._continueWrite(err)\n      return false\n    }\n\n    return true\n  }\n\n  _consumeStream () {\n    const buf = this._buffer.shiftFirst(this._missing)\n    if (buf === null) return false\n\n    this._missing -= buf.byteLength\n    const drained = this._stream.push(buf)\n\n    if (this._missing === 0) {\n      this._stream.push(null)\n      if (drained) this._stream._detach()\n      return drained && this._locked === false\n    }\n\n    return drained\n  }\n\n  _createStream () {\n    return new Source(this, this._header, this._offset)\n  }\n\n  _update () {\n    while (this._buffer.buffered > 0 && !this.destroying) {\n      if (this._missing > 0) {\n        if (this._stream !== null) {\n          if (this._consumeStream() === false) return\n          continue\n        }\n\n        if (this._longHeader === true) {\n          if (this._missing > this._buffer.buffered) break\n          if (this._consumeLongHeader() === false) return false\n          continue\n        }\n\n        const ignore = this._buffer.shiftFirst(this._missing)\n        if (ignore !== null) this._missing -= ignore.byteLength\n        continue\n      }\n\n      if (this._buffer.buffered < 512) break\n      if (this._stream !== null || this._consumeHeader() === false) return\n    }\n\n    this._continueWrite(null)\n  }\n\n  _continueWrite (err) {\n    const cb = this._callback\n    this._callback = noop\n    cb(err)\n  }\n\n  _write (data, cb) {\n    this._callback = cb\n    this._buffer.push(data)\n    this._update()\n  }\n\n  _final (cb) {\n    this._finished = this._missing === 0 && this._buffer.buffered === 0\n    cb(this._finished ? null : new Error('Unexpected end of data'))\n  }\n\n  _predestroy () {\n    this._continueWrite(null)\n  }\n\n  _destroy (cb) {\n    if (this._stream) this._stream.destroy(getStreamError(this))\n    cb(null)\n  }\n\n  [Symbol.asyncIterator] () {\n    let error = null\n\n    let promiseResolve = null\n    let promiseReject = null\n\n    let entryStream = null\n    let entryCallback = null\n\n    const extract = this\n\n    this.on('entry', onentry)\n    this.on('error', (err) => { error = err })\n    this.on('close', onclose)\n\n    return {\n      [Symbol.asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(onnext)\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function consumeCallback (err) {\n      if (!entryCallback) return\n      const cb = entryCallback\n      entryCallback = null\n      cb(err)\n    }\n\n    function onnext (resolve, reject) {\n      if (error) {\n        return reject(error)\n      }\n\n      if (entryStream) {\n        resolve({ value: entryStream, done: false })\n        entryStream = null\n        return\n      }\n\n      promiseResolve = resolve\n      promiseReject = reject\n\n      consumeCallback(null)\n\n      if (extract._finished && promiseResolve) {\n        promiseResolve({ value: undefined, done: true })\n        promiseResolve = promiseReject = null\n      }\n    }\n\n    function onentry (header, stream, callback) {\n      entryCallback = callback\n      stream.on('error', noop) // no way around this due to tick sillyness\n\n      if (promiseResolve) {\n        promiseResolve({ value: stream, done: false })\n        promiseResolve = promiseReject = null\n      } else {\n        entryStream = stream\n      }\n    }\n\n    function onclose () {\n      consumeCallback(error)\n      if (!promiseResolve) return\n      if (error) promiseReject(error)\n      else promiseResolve({ value: undefined, done: true })\n      promiseResolve = promiseReject = null\n    }\n\n    function destroy (err) {\n      extract.destroy(err)\n      consumeCallback(err)\n      return new Promise((resolve, reject) => {\n        if (extract.destroyed) return resolve({ value: undefined, done: true })\n        extract.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nmodule.exports = function extract (opts) {\n  return new Extract(opts)\n}\n\nfunction noop () {}\n\nfunction overflow (size) {\n  size &= 511\n  return size && 512 - size\n}\n", "const constants = { // just for envs without fs\n  S_IFMT: 61440,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960\n}\n\ntry {\n  module.exports = require('fs').constants || constants\n} catch {\n  module.exports = constants\n}\n", "const { Readable, Writable, getStreamError } = require('streamx')\nconst b4a = require('b4a')\n\nconst constants = require('./constants')\nconst headers = require('./headers')\n\nconst DMODE = 0o755\nconst FMODE = 0o644\n\nconst END_OF_TAR = b4a.alloc(1024)\n\nclass Sink extends Writable {\n  constructor (pack, header, callback) {\n    super({ mapWritable, eagerOpen: true })\n\n    this.written = 0\n    this.header = header\n\n    this._callback = callback\n    this._linkname = null\n    this._isLinkname = header.type === 'symlink' && !header.linkname\n    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file'\n    this._finished = false\n    this._pack = pack\n    this._openCallback = null\n\n    if (this._pack._stream === null) this._pack._stream = this\n    else this._pack._pending.push(this)\n  }\n\n  _open (cb) {\n    this._openCallback = cb\n    if (this._pack._stream === this) this._continueOpen()\n  }\n\n  _continuePack (err) {\n    if (this._callback === null) return\n\n    const callback = this._callback\n    this._callback = null\n\n    callback(err)\n  }\n\n  _continueOpen () {\n    if (this._pack._stream === null) this._pack._stream = this\n\n    const cb = this._openCallback\n    this._openCallback = null\n    if (cb === null) return\n\n    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))\n    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))\n\n    this._pack._stream = this\n\n    if (!this._isLinkname) {\n      this._pack._encode(this.header)\n    }\n\n    if (this._isVoid) {\n      this._finish()\n      this._continuePack(null)\n    }\n\n    cb(null)\n  }\n\n  _write (data, cb) {\n    if (this._isLinkname) {\n      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data\n      return cb(null)\n    }\n\n    if (this._isVoid) {\n      if (data.byteLength > 0) {\n        return cb(new Error('No body allowed for this entry'))\n      }\n      return cb()\n    }\n\n    this.written += data.byteLength\n    if (this._pack.push(data)) return cb()\n    this._pack._drain = cb\n  }\n\n  _finish () {\n    if (this._finished) return\n    this._finished = true\n\n    if (this._isLinkname) {\n      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : ''\n      this._pack._encode(this.header)\n    }\n\n    overflow(this._pack, this.header.size)\n\n    this._pack._done(this)\n  }\n\n  _final (cb) {\n    if (this.written !== this.header.size) { // corrupting tar\n      return cb(new Error('Size mismatch'))\n    }\n\n    this._finish()\n    cb(null)\n  }\n\n  _getError () {\n    return getStreamError(this) || new Error('tar entry destroyed')\n  }\n\n  _predestroy () {\n    this._pack.destroy(this._getError())\n  }\n\n  _destroy (cb) {\n    this._pack._done(this)\n\n    this._continuePack(this._finished ? null : this._getError())\n\n    cb()\n  }\n}\n\nclass Pack extends Readable {\n  constructor (opts) {\n    super(opts)\n    this._drain = noop\n    this._finalized = false\n    this._finalizing = false\n    this._pending = []\n    this._stream = null\n  }\n\n  entry (header, buffer, callback) {\n    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')\n\n    if (typeof buffer === 'function') {\n      callback = buffer\n      buffer = null\n    }\n\n    if (!callback) callback = noop\n\n    if (!header.size || header.type === 'symlink') header.size = 0\n    if (!header.type) header.type = modeToType(header.mode)\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n    if (!header.uid) header.uid = 0\n    if (!header.gid) header.gid = 0\n    if (!header.mtime) header.mtime = new Date()\n\n    if (typeof buffer === 'string') buffer = b4a.from(buffer)\n\n    const sink = new Sink(this, header, callback)\n\n    if (b4a.isBuffer(buffer)) {\n      header.size = buffer.byteLength\n      sink.write(buffer)\n      sink.end()\n      return sink\n    }\n\n    if (sink._isVoid) {\n      return sink\n    }\n\n    return sink\n  }\n\n  finalize () {\n    if (this._stream || this._pending.length > 0) {\n      this._finalizing = true\n      return\n    }\n\n    if (this._finalized) return\n    this._finalized = true\n\n    this.push(END_OF_TAR)\n    this.push(null)\n  }\n\n  _done (stream) {\n    if (stream !== this._stream) return\n\n    this._stream = null\n\n    if (this._finalizing) this.finalize()\n    if (this._pending.length) this._pending.shift()._continueOpen()\n  }\n\n  _encode (header) {\n    if (!header.pax) {\n      const buf = headers.encode(header)\n      if (buf) {\n        this.push(buf)\n        return\n      }\n    }\n    this._encodePax(header)\n  }\n\n  _encodePax (header) {\n    const paxHeader = headers.encodePax({\n      name: header.name,\n      linkname: header.linkname,\n      pax: header.pax\n    })\n\n    const newHeader = {\n      name: 'PaxHeader',\n      mode: header.mode,\n      uid: header.uid,\n      gid: header.gid,\n      size: paxHeader.byteLength,\n      mtime: header.mtime,\n      type: 'pax-header',\n      linkname: header.linkname && 'PaxHeader',\n      uname: header.uname,\n      gname: header.gname,\n      devmajor: header.devmajor,\n      devminor: header.devminor\n    }\n\n    this.push(headers.encode(newHeader))\n    this.push(paxHeader)\n    overflow(this, paxHeader.byteLength)\n\n    newHeader.size = header.size\n    newHeader.type = header.type\n    this.push(headers.encode(newHeader))\n  }\n\n  _doDrain () {\n    const drain = this._drain\n    this._drain = noop\n    drain()\n  }\n\n  _predestroy () {\n    const err = getStreamError(this)\n\n    if (this._stream) this._stream.destroy(err)\n\n    while (this._pending.length) {\n      const stream = this._pending.shift()\n      stream.destroy(err)\n      stream._continueOpen()\n    }\n\n    this._doDrain()\n  }\n\n  _read (cb) {\n    this._doDrain()\n    cb()\n  }\n}\n\nmodule.exports = function pack (opts) {\n  return new Pack(opts)\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nfunction noop () {}\n\nfunction overflow (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.subarray(0, 512 - size))\n}\n\nfunction mapWritable (buf) {\n  return b4a.isBuffer(buf) ? buf : b4a.from(buf)\n}\n", "exports.extract = require('./extract')\nexports.pack = require('./pack')\n", "import { program } from 'commander';\n\nimport { add, AddOptions } from './add';\nimport { install } from './install';\nimport { remove } from './remove';\n\nimport { TOOL_NAME, VERSION } from '../constants';\n\nexport const cli = async () => {\n  let exitCode;\n\n  program.name(TOOL_NAME).version(VERSION);\n\n  program\n    .command('add [packages...]')\n    .description('installs one or more dependencies into the project')\n    .option('-D, --dev', 'save package to `devDependencies`')\n    .option('-P, --peer', 'save package to `peerDependencies`')\n    .option('-O, --optional', 'save package to `optionalDependencies`')\n    // .option('-E, --exact', 'install exact version of a package')\n    .option('-T, --tilde', 'install most recent release with the same minor version')\n    .action(async (specifierList: string[], options: AddOptions) => {\n      exitCode = await add(specifierList, options);\n    });\n\n  program\n    .command('install', { isDefault: true })\n    .alias('i')\n    .description('installs all the dependencies of a project')\n    .option('-P, --prod', 'modules from `devDependencies` will not be installed')\n    .action(async (options) => {\n      exitCode = await install(options);\n    });\n\n  program\n    .command('remove [packages...]')\n    .alias('rm')\n    .description('removes one or more dependencies from the project')\n    .action(async (nameList: string[]) => {\n      exitCode = await remove(nameList);\n    });\n\n  program\n    .command('run')\n    .description('runs a script from the package')\n    .action(async () => {});\n\n  await program.parseAsync();\n\n  return exitCode;\n};\n", "import commander from './index.js';\n\n// wrapper to provide named exports for ESM.\nexport const {\n  program,\n  createCommand,\n  createArgument,\n  createOption,\n  CommanderError,\n  InvalidArgumentError,\n  InvalidOptionArgumentError, // deprecated old name\n  Command,\n  Argument,\n  Option,\n  Help,\n} = commander;\n", "import { promises as fs } from 'fs';\nimport detectIndent from 'detect-indent';\n\nimport { ensureCacheDirExists } from '../../cache';\nimport { downloadMetadata } from '../../resolver/registry';\nimport { addScript, PackageMetadata, AddEventType, AddOptions } from './addScript';\nimport { install } from '../install';\nexport { AddOptions } from './addScript';\nimport { TOOL_NAME, VERSION } from '../../constants';\n\nconst getMetadata = async ({ name }: { name: string }) => {\n  const metadata = await downloadMetadata(name);\n\n  return { name, metadata };\n};\n\nexport const add = async (specifierList: string[], options: AddOptions): Promise<number> => {\n  console.log(`${TOOL_NAME} add ${VERSION}`);\n  await ensureCacheDirExists();\n  const packageJsonPath = 'package.json';\n  const text = await fs.readFile(packageJsonPath, 'utf8');\n  const indent = detectIndent(text).indent || '  ';\n  const json = JSON.parse(text);\n\n  const script = addScript({ json }, specifierList, options);\n\n  const promises = new Map<string, Promise<PackageMetadata>>();\n  const metadata = new Map<string, any>();\n\n  let isModified = false;\n  let next;\n  try {\n    let nextArg: PackageMetadata | undefined;\n    do {\n      next = script.next(nextArg);\n      nextArg = undefined;\n\n      if (next.done) break;\n\n      const step = next.value;\n      if (step.type === AddEventType.GET_METADATA) {\n        const { name } = step;\n        promises.set(name, getMetadata({ name }));\n      } else if (step.type === AddEventType.NEXT_METADATA) {\n        const resolvedPromise = await Promise.race(promises.values());\n        promises.delete(resolvedPromise.name);\n        nextArg = resolvedPromise;\n        metadata.set(resolvedPromise.name, resolvedPromise.metadata);\n      } else if (step.type === AddEventType.MODIFY) {\n        const newText = JSON.stringify(step.json, undefined, indent);\n        if (newText !== text) {\n          console.log('package.json changed');\n          isModified = true;\n          await fs.writeFile(packageJsonPath, newText);\n        }\n      }\n    } while (!next.done);\n  } finally {\n    await Promise.all(promises.values());\n  }\n\n  if (isModified) {\n    return await install({ metadata, skipBanner: true, verbose: true });\n  } else {\n    return 0;\n  }\n};\n", "import { promises as fs } from 'fs';\nimport crypto from 'crypto';\nimport os from 'os';\nimport path from 'path';\n\nimport { TOOL_NAME, CACHE_VERSION, DOWNLOAD_DIR } from '../constants';\n\nconst dirCache = new Set<string>();\nlet isDownloadDirPrepared = false;\n\nexport const ensureDownloadDirExists = async (): Promise<void> => {\n  if (isDownloadDirPrepared) return;\n\n  const isExists = await isPathExists(DOWNLOAD_DIR);\n  if (isExists) {\n    const entries = await fs.readdir(DOWNLOAD_DIR);\n    for (const entry of entries) {\n      await fs.rm(path.join(DOWNLOAD_DIR, entry), { recursive: true });\n    }\n  } else {\n    await cachedCreateDir(DOWNLOAD_DIR);\n  }\n\n  isDownloadDirPrepared = true;\n};\n\nexport const isPathExists = async (entryPath: string) =>\n  fs\n    .stat(entryPath)\n    .then(() => true)\n    .catch(() => false);\n\nexport const cachedCreateDir = async (dirPath: string) => {\n  if (!dirCache.has(dirPath)) {\n    await fs.mkdir(dirPath, { recursive: true });\n\n    const parts = dirPath.split(path.sep);\n    for (let idx = 1; idx <= parts.length; idx++) {\n      let subPath = parts.slice(0, idx).join(path.sep);\n      subPath = subPath === '' ? path.sep : subPath;\n      dirCache.add(subPath);\n    }\n  }\n};\n\nconst getCacheDir = () => {\n  let cacheHome;\n  if (process.platform === 'win32') {\n    cacheHome = process.env.LOCALAPPDATA;\n  } else if (process.env.XDG_CACHE_HOME) {\n    cacheHome = process.env.XDG_CACHE_HOME;\n  }\n\n  if (!cacheHome) {\n    cacheHome = path.join(os.homedir(), '.cache');\n  }\n\n  return path.join(cacheHome, TOOL_NAME, CACHE_VERSION);\n};\n\nlet isCacheDirExists: boolean | null = null;\n\nexport const ensureCacheDirExists = async () => {\n  if (isCacheDirExists === null) {\n    isCacheDirExists =\n      (await fs\n        .stat(path.join(CACHE_DIR, 'tarballs'))\n        .then(() => true)\n        .catch(() => false)) &&\n      (await fs\n        .stat(path.join(CACHE_DIR, 'metadata'))\n        .then(() => true)\n        .catch(() => false));\n  }\n\n  if (isCacheDirExists === false) {\n    await fs.mkdir(path.join(CACHE_DIR, 'tarballs'), { recursive: true });\n    await fs.mkdir(path.join(CACHE_DIR, 'metadata'), { recursive: true });\n\n    isCacheDirExists = true;\n  }\n};\n\nexport const CACHE_DIR = getCacheDir();\n\nexport const atomicFileWrite = async (filePath: string, content: string | Buffer) => {\n  const tmpPath = path.join(path.dirname(filePath), `${crypto.randomBytes(16).toString(`hex`)}.tmp`);\n  try {\n    await fs.writeFile(tmpPath, content);\n    try {\n      await fs.link(tmpPath, filePath);\n    } catch {\n      // empty\n    }\n  } finally {\n    await fs.unlink(tmpPath);\n  }\n};\n", "import path from 'path';\nimport metadata from '../package.json';\n\nexport const VERSION = metadata.version;\nexport const TOOL_NAME = 'nari';\nexport const CACHE_VERSION = `v1`;\nexport const NODE_MODULES = 'node_modules';\nexport const DOT_BIN = '.bin';\nexport const DOWNLOAD_DIR = path.join(NODE_MODULES, `.${TOOL_NAME}`);\nexport const BUILD_SCRIPTS = ['preinstall', 'install', 'postinstall'];\nexport const DEPENDENCY_TYPES = ['dependencies', 'devDependencies', 'peerDependencies', 'optionalDependencies'];\n", "{\n  \"name\": \"nari\",\n  \"version\": \"0.0.7\",\n  \"bin\": \"./lib/nari\",\n  \"scripts\": {\n    \"build\": \"rm -rf ./lib && esbuild src/index.ts --sourcemap --bundle --platform=node --target=node18 --external:./cli --outfile=lib/nari '--banner:js=#!/usr/bin/env node' && chmod +x lib/nari && esbuild src/cli/index.ts --sourcemap --bundle --platform=node --target=node18 --outfile=lib/cli.js\",\n    \"test\": \"jest\",\n    \"nari\": \"nari build && node --enable-source-maps lib/nari\",\n    \"test:watch\": \"jest --watch\",\n    \"lint\": \"eslint --fix\",\n    \"prepack\": \"nari build && nari lint && nari test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/narijs/nari\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/narijs/nari/issues\"\n  },\n  \"keywords\": [\n    \"modules\",\n    \"install\",\n    \"package manager\"\n  ],\n  \"author\": \"SysGears (Cyprus) Limited\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.13\",\n    \"@types/node\": \"^22.7.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.7.0\",\n    \"@typescript-eslint/parser\": \"^8.7.0\",\n    \"commander\": \"^12.1.0\",\n    \"detect-indent\": \"^6.0.0\",\n    \"micromatch\": \"^4.0.8\",\n    \"semver\": \"^7.6.3\",\n    \"tar-stream\": \"^3.1.7\",\n    \"esbuild\": \"^0.24.0\",\n    \"esbuild-jest\": \"^0.5.0\",\n    \"eslint\": \"^9.11.1\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"eslint-plugin-header\": \"^3.1.1\",\n    \"eslint-plugin-jest\": \"^28.8.3\",\n    \"eslint-plugin-prettier\": \"^5.2.1\",\n    \"husky\": \"^9.1.6\",\n    \"jest\": \"^29.7.0\",\n    \"lint-staged\": \"^15.2.10\",\n    \"prettier\": \"^3.3.3\",\n    \"typescript\": \"~5.5.0\"\n  },\n  \"lint-staged\": {\n    \"*.ts\": [\n      \"eslint --fix -c tslint.json\",\n      \"git add\"\n    ]\n  },\n  \"prettier\": {\n    \"printWidth\": 120,\n    \"singleQuote\": true,\n    \"parser\": \"typescript\"\n  },\n  \"husky\": {\n    \"pre-commit\": \"lint-staged\"\n  },\n  \"lockTime\": \"2024-10-02T12:40:33.928Z\"\n}", "import { promises as fs } from 'fs';\nimport path from 'path';\nimport { PassThrough, Writable } from 'stream';\nimport { pipeline } from 'stream/promises';\nimport zlib from 'zlib';\n\nimport { CACHE_DIR, atomicFileWrite, isPathExists } from '../cache';\nimport { get } from '../net';\n\nconst minimizeMetadata = (metaJson: any) => {\n  for (const key of Object.keys(metaJson)) {\n    if (['name', 'version', 'dist-tags', 'versions', 'time'].indexOf(key) < 0) {\n      delete metaJson[key];\n    }\n  }\n\n  for (const versionJson of Object.values<any>(metaJson.versions)) {\n    for (const key of Object.keys(versionJson)) {\n      if (\n        [\n          'name',\n          'version',\n          'license',\n          'engines',\n          'dist',\n          'exports',\n          'scripts',\n          'bin',\n          'dependencies',\n          'peerDependencies',\n          'optionalDependencies',\n          'peerDependenciesMeta',\n          'os',\n          'cpu',\n          'libc',\n        ].indexOf(key) < 0\n      ) {\n        delete versionJson[key];\n      }\n    }\n    for (const key of Object.keys(versionJson['dist'])) {\n      if (['tarball', 'integrity'].indexOf(key) < 0) {\n        delete versionJson['dist'][key];\n      }\n    }\n    for (const key of Object.keys(versionJson['scripts'] || {})) {\n      if (\n        ['preinstall', 'install', 'postinstall', 'prepublish', 'preprepare', 'prepare', 'postprepare'].indexOf(key) < 0\n      ) {\n        delete versionJson['scripts'][key];\n      }\n    }\n    if (Object.keys(versionJson['scripts'] || {}).length === 0) {\n      delete versionJson['scripts'];\n    }\n  }\n  metaJson['_nariRefVer'] = 1;\n};\n\nconst getMetadataCacheFilePath = (name: string): string => {\n  const filename = `${name.replaceAll('/', '-')}.tjson`;\n  const filePath = path.join(CACHE_DIR, 'metadata', filename);\n  return filePath;\n};\n\ntype CachedMetadata = { metaJson: any; cacheMeta: any };\n\nexport const getCachedMetadata = async (name: string): Promise<CachedMetadata | null> => {\n  const filePath = getMetadataCacheFilePath(name);\n\n  const isFileCached = await isPathExists(filePath);\n\n  let metaJson, jsonList;\n  if (isFileCached) {\n    const contents = await fs.readFile(filePath, 'utf8');\n    jsonList = contents.split('\\n');\n    const cacheMeta = JSON.parse(jsonList[0]);\n    cacheMeta.date = new Date(cacheMeta.date);\n    metaJson = JSON.parse(jsonList[1]);\n    return { metaJson, cacheMeta };\n  } else {\n    return null;\n  }\n};\n\nexport const downloadMetadata = async (name: string, cachedMetadata?: CachedMetadata | null): Promise<any> => {\n  const headers = { 'Accept-Encoding': 'gzip' };\n\n  if (cachedMetadata) {\n    headers['if-none-match'] = cachedMetadata.cacheMeta.etag;\n  }\n\n  try {\n    const response = await get(`https://registry.npmjs.org/${name}`, { headers });\n\n    const unzip = response.headers['content-encoding'] === 'gzip' ? zlib.createGunzip() : new PassThrough();\n    const chunks: Buffer[] = [];\n\n    await pipeline(\n      response,\n      unzip,\n      new Writable({\n        write(chunk, _encoding, callback) {\n          chunks.push(chunk);\n          callback();\n        },\n      }),\n    );\n\n    const data = Buffer.concat(chunks);\n\n    let metaJson;\n    if (response.statusCode === 304) {\n      metaJson = cachedMetadata!.metaJson;\n      // console.log(`metadata cache hit for ${name}, cf status: ${response.headers.get('cf-cache-status')}`);\n    } else if (response.statusCode === 200) {\n      const etag = response.headers['etag'];\n      const date = response.headers['date'];\n      const cachedFilePath = getMetadataCacheFilePath(name);\n      if (cachedMetadata) {\n        // console.log(`metadata for ${name} changed, old etag: ${cachedMetadata.cacheMeta.etag}, new etag: ${etag}`);\n        await fs.rm(cachedFilePath, { force: true });\n      }\n\n      metaJson = JSON.parse(data.toString('utf-8'));\n      minimizeMetadata(metaJson);\n\n      await atomicFileWrite(cachedFilePath, `${JSON.stringify({ etag, date })}\\n${JSON.stringify(metaJson)}`);\n    } else {\n      throw new Error(`the registry replied with status: ${response.statusCode}: ${data.toString('utf-8')}`);\n    }\n\n    return metaJson;\n  } catch (e: any) {\n    e.message = `While fetching https://registry.npmjs.org/${name}: ${e.message}`;\n    throw e;\n  }\n};\n", "import dns, { LookupAddress } from 'dns';\nimport http from 'http';\nimport https from 'https';\nimport { OutgoingHttpHeaders } from 'http2';\nimport { TOOL_NAME, VERSION } from '../constants';\n\nlet ipv6 = true;\n\nexport const disableIpv6 = () => (ipv6 = false);\n\nconst agent = new https.Agent({\n  lookup: (hostname, opts, cb) => {\n    dns.lookup(hostname, opts, (err, address, family) => {\n      let resolvedAddress: string | LookupAddress[] = address;\n      if (Array.isArray(address) && !ipv6) {\n        resolvedAddress = address.filter((a) => a.family !== 6);\n      }\n      cb(err, resolvedAddress as unknown as string, family);\n    });\n  },\n  keepAlive: true,\n  maxSockets: 64,\n});\n\nhttps.globalAgent = agent;\n\nexport type GetOptions = {\n  headers?: OutgoingHttpHeaders;\n};\n\nconst request = async (\n  url: string,\n  options: http.RequestOptions,\n): Promise<{ response: http.IncomingMessage; error?: undefined } | { response?: undefined; error: any }> => {\n  return new Promise((resolve) => {\n    https.get(url, options, (response) => resolve({ response })).on('error', (error) => resolve({ error }));\n  });\n};\n\nconst MAX_RETRIES = 5;\nconst RETRY_TIMEOUT = 1000;\n\nexport const get = async (url: string, opts?: GetOptions): Promise<http.IncomingMessage> => {\n  const headers = opts?.headers || {};\n\n  headers['User-Agent'] = `${TOOL_NAME}/${VERSION} npm/? node/${process.version} ${process.platform} ${process.arch}`;\n\n  let retries = 0;\n  let lastError;\n\n  do {\n    const { response, error } = await request(url, { headers });\n    if (response) {\n      return response;\n    } else {\n      lastError = error;\n    }\n\n    if (error.code && error.code === 'ENETUNREACH') {\n      disableIpv6();\n    }\n\n    retries++;\n    if (retries > 1) {\n      await new Promise((r) => setTimeout(r, RETRY_TIMEOUT));\n    }\n  } while (retries < MAX_RETRIES);\n\n  throw lastError;\n};\n", "import semver from 'semver';\n\nimport { PurePackage } from '../../resolver/workspace';\nimport { parseSpecifier } from '../../resolver';\nimport { getDependencies } from '../../resolver/dependencies';\n\nexport enum AddEventType {\n  MODIFY = 'modify',\n  GET_METADATA = 'get_metadata',\n  NEXT_METADATA = 'next_metadata',\n}\n\nexport type AddOptions = {\n  dev?: boolean;\n  peer?: boolean;\n  optional?: boolean;\n  tilde?: boolean;\n};\n\nexport type AddEvent =\n  | {\n      type: AddEventType.MODIFY;\n      json: any;\n    }\n  | {\n      type: AddEventType.GET_METADATA;\n      name: string;\n    }\n  | {\n      type: AddEventType.NEXT_METADATA;\n    };\n\nexport type PackageMetadata = { name: string; metadata: any };\n\nexport const addScript = function* (\n  pkg: PurePackage,\n  specifierList: string[],\n  opts?: AddOptions,\n): Generator<AddEvent, any, PackageMetadata | any> {\n  const options: AddOptions = opts || {};\n  const pendingMetadata = new Set<string>();\n  const receivedMetadata = new Map<string, any>();\n  const unresolvedSpecifiers = new Set<{ name: string; range: string; alias: string }>();\n  const prefix = options.tilde ? `~` : `^`;\n\n  let dependencyType = 'dependencies';\n  if (options.dev) {\n    dependencyType = 'devDependencies';\n  } else if (options.peer) {\n    dependencyType = 'peerDependencies';\n  } else if (options.optional) {\n    dependencyType = 'optionalDependencies';\n  }\n\n  for (const specifier of specifierList) {\n    const { name, range, alias } = parseSpecifier(specifier);\n    if (!pendingMetadata.has(name)) {\n      pendingMetadata.add(name);\n      yield { type: AddEventType.GET_METADATA, name };\n\n      unresolvedSpecifiers.add({ name, range, alias });\n    }\n  }\n\n  while (pendingMetadata.size > 0) {\n    const packageMetadata = yield { type: AddEventType.NEXT_METADATA };\n    if (!packageMetadata) {\n      throw new Error('Unable to receive packages metadata, aborting...');\n    }\n\n    const { name, metadata } = packageMetadata;\n    pendingMetadata.delete(name);\n    receivedMetadata.set(name, metadata);\n  }\n\n  let isModified = false;\n  const nextJson = structuredClone(pkg.json);\n  for (const { name, range, alias } of unresolvedSpecifiers) {\n    const metadata = receivedMetadata.get(name)!;\n    const availableVersions = Object.keys(metadata.versions);\n    const version = semver.maxSatisfying(availableVersions, range);\n    const targetRange = range !== '' ? range : `${prefix}${version}`;\n    const depRange = alias ? `npm:${name}:${targetRange}` : targetRange;\n    const dependencies = getDependencies(pkg.json, true);\n    let existingRange = dependencies.regular.get(name);\n    if (depRange !== existingRange) {\n      const targetDependencyType = dependencies.regularType.get(name) || dependencyType;\n      nextJson[targetDependencyType] = nextJson[targetDependencyType] || {};\n      nextJson[targetDependencyType][alias || name] = depRange;\n      isModified = true;\n    }\n  }\n\n  if (isModified) {\n    yield { type: AddEventType.MODIFY, json: nextJson };\n  }\n};\n", "import { promises as fs } from 'fs';\nimport path from 'path';\nimport detectIndent from 'detect-indent';\n\nimport { readWorkspaceTree } from './workspace';\nimport {\n  PackageMetadata,\n  ResolveEventType,\n  resolveScript,\n  resolveStateDeserializer,\n  resolveStateSerializer,\n} from './resolveScript';\nimport { getCachedMetadata, downloadMetadata } from './registry';\nimport { NODE_MODULES } from '../constants';\nimport { cachedCreateDir } from '../cache';\n\nexport type ResolveOptions = {\n  metadata?: Map<string, any>;\n  prod?: boolean;\n  skipBanner?: boolean;\n  verbose?: boolean;\n};\n\nexport const RESOLVE_STATE_FILE = '.resolve-state.json';\nconst RESOLVE_STATE_PATH = path.join(NODE_MODULES, RESOLVE_STATE_FILE);\nconst RESOLVE_STATE_VERSION = '1';\n\nconst getMetadata = async ({ name, lockTime }: { name: string; lockTime?: Date }) => {\n  let fresh: boolean;\n  const cachedMetadata = await getCachedMetadata(name);\n  let metadata;\n  if (lockTime && cachedMetadata && cachedMetadata.cacheMeta.date >= lockTime) {\n    fresh = false;\n    metadata = cachedMetadata.metaJson;\n  } else {\n    fresh = true;\n    metadata = await downloadMetadata(name, cachedMetadata);\n  }\n\n  return { name, metadata, fresh };\n};\n\nexport const resolve = async (opts?: ResolveOptions) => {\n  const options = opts || {};\n  const packageJsonPath = 'package.json';\n  const text = await fs.readFile(packageJsonPath, 'utf8');\n  const indent = detectIndent(text).indent || '  ';\n  const json = JSON.parse(text);\n  const pkg = await readWorkspaceTree({ json, relativePath: '.' });\n\n  let prevState;\n  let prevStateText;\n  try {\n    prevStateText = await fs.readFile(RESOLVE_STATE_PATH, 'utf8');\n    prevState = JSON.parse(prevStateText, resolveStateDeserializer);\n  } catch {\n    // empty\n  }\n\n  const script = resolveScript(\n    pkg,\n    {\n      autoInstallPeers: true,\n      resolutionOptimization: true,\n      receivedMetadata: options.metadata,\n      prod: options.prod,\n      verbose: options.verbose,\n    },\n    prevState,\n  );\n\n  const promises = new Map<string, Promise<PackageMetadata>>();\n  try {\n    let next;\n    let nextArg: PackageMetadata | undefined;\n    do {\n      next = script.next(nextArg);\n      nextArg = undefined;\n\n      if (next.done) break;\n\n      const step = next.value;\n      if (step.type === ResolveEventType.GET_METADATA) {\n        const { name, lockTime } = step;\n        promises.set(name, getMetadata({ name, lockTime }));\n      } else if (step.type === ResolveEventType.NEXT_METADATA) {\n        const resolvedPromise = await Promise.race(promises.values());\n        promises.delete(resolvedPromise.name);\n        nextArg = resolvedPromise;\n      }\n    } while (!next.done);\n\n    const resolveState = next.value.state;\n    if (resolveState) {\n      resolveState.version = RESOLVE_STATE_VERSION;\n\n      await cachedCreateDir(NODE_MODULES);\n\n      const newStateText = JSON.stringify(resolveState, resolveStateSerializer, 0);\n      if (newStateText !== prevStateText) {\n        if (prevStateText) console.log('resolve state changed');\n        if (prevStateText) {\n          await fs.writeFile(RESOLVE_STATE_PATH + '.old', JSON.stringify(JSON.parse(prevStateText), null, 2));\n          await fs.writeFile(RESOLVE_STATE_PATH + '.new', JSON.stringify(JSON.parse(newStateText), null, 2));\n        }\n        await fs.writeFile(RESOLVE_STATE_PATH, newStateText);\n      }\n\n      const newText = JSON.stringify({ ...json, lockTime: next.value.state.lockTime.toISOString() }, undefined, indent);\n      if (newText !== text) {\n        console.log('package.json changed');\n        await fs.writeFile(packageJsonPath, newText);\n      }\n    } else {\n      console.log('deleted resolve state');\n      await fs.rm(RESOLVE_STATE_PATH, { force: true });\n    }\n\n    return next.value.graph;\n  } finally {\n    await Promise.all(promises.values());\n  }\n};\n", "import { promises as fs } from 'fs';\nimport mm from 'micromatch';\nimport path from 'path';\n\nimport { NODE_MODULES } from '../constants';\n\nconst IGNORED_WORKSPACE_DIRECTORIES = new Set(['.git', NODE_MODULES]);\n\nexport type PurePackage = {\n  json: any;\n  workspacePath?: string;\n  workspaces?: PurePackage[];\n};\n\nexport const readWorkspaceTree = async ({\n  json,\n  relativePath,\n  directories,\n}: {\n  json: any;\n  relativePath: string;\n  directories?: string[];\n}): Promise<PurePackage> => {\n  const pkg: PurePackage = { json, workspacePath: relativePath };\n\n  const workspaceConfig = Array.isArray(json.workspaces) ? { packages: json.workspaces } : json.workspaces;\n  if (workspaceConfig?.packages?.length > 0) {\n    if (!directories) {\n      directories = await getProjectDirectories();\n    }\n\n    const matchedDirectories = mm(directories, workspaceConfig.packages);\n    for (const dir of matchedDirectories) {\n      try {\n        const json = JSON.parse(await fs.readFile(path.join(dir, 'package.json'), 'utf8'));\n        const relativeDirectories: string[] = [];\n        for (const subdir of directories) {\n          const subdirRelativePath = path.relative(dir, subdir);\n          if (subdirRelativePath !== '' && !subdirRelativePath.startsWith('.')) {\n            relativeDirectories.push(subdirRelativePath);\n          }\n        }\n        const workspace = await readWorkspaceTree({ json, relativePath: dir, directories: relativeDirectories });\n        pkg.workspaces = pkg.workspaces || [];\n        pkg.workspaces.push(workspace);\n      } catch (e: any) {\n        if (e?.code !== 'ENOENT') throw e;\n      }\n    }\n  }\n\n  return pkg;\n};\n\nconst getProjectDirectories = async (): Promise<string[]> => {\n  const directories: string[] = [];\n\n  const addDirectory = async (baseDir: string) => {\n    const entries = await fs.readdir(baseDir, { withFileTypes: true });\n    for (const entry of entries) {\n      if (entry.isDirectory() && !IGNORED_WORKSPACE_DIRECTORIES.has(entry.name)) {\n        const dir = path.join(baseDir, entry.name);\n        directories.push(dir);\n        await addDirectory(dir);\n      }\n    }\n  };\n\n  await addDirectory('.');\n\n  return directories;\n};\n", "import semver from 'semver';\n\nimport { getDependencies } from './dependencies';\nimport { Graph, PackageType } from '../hoister';\nimport { PurePackage } from './workspace';\nimport { BUILD_SCRIPTS } from '../constants';\n\ntype GraphId = {\n  protocol?: string;\n  scope?: string;\n  basename: string;\n  version?: string;\n  alias?: string;\n  resolutions?: Set<string>;\n  autoPeerNames?: Set<string>;\n};\n\nexport type Package = {\n  id: string;\n  name: string;\n  version: string;\n  path?: string;\n  metadata?: any;\n  json: any;\n  workspaces?: Set<Package>;\n};\n\nexport type MetadataMap = Map<string, { version: string; metaJson: any }>;\n\nexport type ResolveOptions = {\n  autoInstallPeers?: boolean;\n  resolutionOptimization?: boolean;\n  traceRangeUsages?: boolean;\n  prod?: boolean;\n  dump?: boolean;\n  cpu?: string;\n  os?: string;\n  libc?: string | null;\n  receivedMetadata?: Map<string, any>;\n  verbose?: boolean;\n};\n\nexport type ResolveEvent =\n  | {\n      type: ResolveEventType.GET_METADATA;\n      name: string;\n      lockTime?: Date;\n    }\n  | {\n      type: ResolveEventType.NEXT_METADATA;\n    };\n\nexport type PackageMetadata = { name: string; metadata: any; fresh: boolean };\n\nexport const enum ResolveEventType {\n  GET_METADATA = 'get_metadata',\n  NEXT_METADATA = 'next_metadata',\n}\n\nexport type ResolveResult = {\n  graph: Graph;\n  state?: ResolveState;\n};\n\nexport type ResolveState = {\n  resolutions: Resolutions;\n  lockTime: Date;\n};\n\nexport type Resolutions = Map<string, { meta: any; ranges: Map<string, string> }>;\n\ntype DeclaredPackageRanges = Map<string, Map<string, Set<string>>>;\ntype ResolvedPackageRanges = Map<string, Map<string, ResolvedRangeInfo>>;\ntype UnresolvedPackageRanges = Map<string, Set<string>>;\ntype RequestedMetadata = Map<string, { fresh: boolean }>;\ntype ReceivedMetadata = Map<string, { metadata: any; fresh: boolean }>;\n\ntype ResolvedRangeInfo = { name: string; range: string; version: string; isWorkspace?: boolean };\ntype WorkspaceVersions = Map<string, Set<string>>;\n\nexport const resolveStateDeserializer = (key, value) => {\n  if (['resolutions', 'ranges'].indexOf(key) >= 0) {\n    return new Map(value);\n  } else {\n    return value;\n  }\n};\n\nexport const resolveStateSerializer = (key, value) => {\n  if (['resolutions', 'ranges'].indexOf(key) >= 0) {\n    return Array.from(value.entries());\n  } else if (key.startsWith('_')) {\n    return undefined;\n  } else {\n    return value;\n  }\n};\n\nconst getWorkspaceName = (node: PurePackage) => (node.json.name as string) || `workspace:${node.workspacePath}`;\nconst getWorkspaceVersion = (node: PurePackage) => (node.json.version as string) || `0.0.0`;\n\nconst parseRange = (range: string): { version: string; alias?: string; protocol?: string } => {\n  let version, alias, protocol;\n\n  version = range;\n  const protocolParts = range.split(':');\n\n  if (protocolParts.length === 3 && protocol === 'npm') {\n    alias = protocolParts[1];\n    version = protocolParts[2];\n  }\n\n  if (protocolParts.length > 1) {\n    protocol = protocolParts[0];\n    version = protocolParts.slice(1).join(':');\n  }\n\n  return { version, alias, protocol };\n};\n\nconst parsePackageName = (name: string): { scope?: string; basename: string } => {\n  const idx = name.indexOf('/');\n  return idx < 0 ? { basename: name } : { scope: name.substring(0, idx), basename: name.substring(idx + 1) };\n};\n\nconst stringifyGraphId = (graphId: GraphId): string =>\n  `${stringifyPackageId(graphId)}${graphId.alias ? '>' + graphId.alias : ''}${graphId.resolutions ? '#' + Array.from(graphId.resolutions).join(',') : ''}${graphId.autoPeerNames ? '|' + Array.from(graphId.autoPeerNames).join(',') : ''}`;\nconst stringifyPackageId = (graphId: GraphId): string =>\n  `${graphId.protocol ? graphId.protocol + ':' : ''}${graphId.scope ? graphId.scope + '/' : ''}${graphId.basename}${graphId.version ? '@' + graphId.version : ''}`;\n\nconst assignId = ({\n  pkg,\n  name,\n  version,\n  parentDependencyNames,\n  resolutionPath,\n  resolutions,\n  options,\n}: {\n  pkg: PurePackage;\n  name: string;\n  version: string;\n  parentDependencyNames: Set<string>;\n  resolutionPath: string;\n  resolutions: Map<string, string>;\n  options: ResolveOptions;\n}): { idProps: GraphId; dependencies: Map<string, string>; peerNames: Set<string>; optionalNames: Set<string> } => {\n  const rawDependencies = getDependencies(pkg.json, options.prod ? false : !!pkg.workspacePath);\n  const dependencies = new Map();\n  const peerNames = new Set<string>();\n\n  const idProps: GraphId = { ...parsePackageName(name), ...parseRange(version) };\n\n  for (const [depName, depRange] of rawDependencies.regular) {\n    const { resolution, range } = getResolutionRange({\n      resolutions,\n      resolutionPath: getResolutionPath(depName, resolutionPath),\n      depRange,\n    });\n    if (resolution && !pkg.workspacePath) {\n      if (!idProps.resolutions) {\n        idProps.resolutions = new Set();\n      }\n      idProps.resolutions.add(depName);\n    }\n    dependencies.set(depName, range);\n  }\n\n  for (const [depName, depRange] of rawDependencies.peer) {\n    if (rawDependencies.optionalPeerNames.has(depName)) continue;\n\n    if (options.autoInstallPeers) {\n      if (!parentDependencyNames.has(depName)) {\n        dependencies.set(depName, depRange);\n        if (!pkg.workspacePath) {\n          if (!idProps.autoPeerNames) {\n            idProps.autoPeerNames = new Set();\n          }\n          idProps.autoPeerNames.add(depName);\n        }\n      } else {\n        peerNames.add(depName);\n      }\n    } else {\n      peerNames.add(depName);\n    }\n  }\n\n  return { idProps, dependencies, peerNames, optionalNames: rawDependencies.optionalNames };\n};\n\nconst getLibc = () => {\n  if (process.platform === 'linux') {\n    const report: any = process.report?.getReport() || ({} as any);\n    if (report.header?.glibcVersionRuntime) {\n      return 'glibc';\n    } else if (Array.isArray(report.sharedObjects) && report.sharedObjects.some(isMusl)) {\n      return 'musl';\n    }\n  }\n  return null;\n};\n\nconst isMusl = (file) => file.includes('libc.musl-') || file.includes('ld-musl-');\n\nconst isPackageJsonFieldCompatible = (actual: string | null, rules?: Array<string>) => {\n  if (!rules || !actual) return true;\n\n  let isNotAllowlist = true;\n  let isBlocklist = false;\n\n  for (const rule of rules) {\n    if (rule[0] === `!`) {\n      isBlocklist = true;\n\n      if (actual === rule.slice(1)) {\n        return false;\n      }\n    } else {\n      isNotAllowlist = false;\n\n      if (rule === actual) {\n        return true;\n      }\n    }\n  }\n\n  // Blocklists with allowlisted items should be treated as allowlists for `os`, `cpu` and `libc` in `package.json`\n  return isBlocklist && isNotAllowlist;\n};\n\nconst resolveRange = function* ({\n  name,\n  range,\n  resolvedPackageRanges,\n  unresolvedPackageRanges,\n  workspaceVersions,\n  requestedMetadata,\n  receivedMetadata,\n  lockTime,\n  state,\n}: {\n  name: string;\n  range: string;\n  resolvedPackageRanges: ResolvedPackageRanges;\n  unresolvedPackageRanges: UnresolvedPackageRanges;\n  workspaceVersions?: WorkspaceVersions;\n  requestedMetadata: RequestedMetadata;\n  receivedMetadata: ReceivedMetadata;\n  lockTime: Date;\n  state?: ResolveState;\n}) {\n  let resolvedRangeInfo = resolvedPackageRanges.get(name)?.get(range);\n  if (!resolvedRangeInfo && workspaceVersions) {\n    const versions = workspaceVersions.get(name);\n    if (versions) {\n      const version = semver.maxSatisfying(Array.from(versions.keys()), range, true);\n      if (version) {\n        let resolvedRanges = resolvedPackageRanges.get(name);\n        if (!resolvedRanges) {\n          resolvedRanges = new Map();\n          resolvedPackageRanges.set(name, resolvedRanges);\n        }\n        resolvedRangeInfo = { name, range, version, isWorkspace: true };\n        resolvedRanges.set(range, resolvedRangeInfo);\n      }\n    }\n  }\n\n  if (!resolvedRangeInfo && state) {\n    const version = state.resolutions.get(name)?.ranges.get(range);\n    if (version) {\n      let resolvedRanges = resolvedPackageRanges.get(name);\n      if (!resolvedRanges) {\n        resolvedRanges = new Map();\n        resolvedPackageRanges.set(name, resolvedRanges);\n      }\n      resolvedRangeInfo = { name, range, version };\n      resolvedRanges.set(range, resolvedRangeInfo);\n    }\n  }\n\n  const metadataEntry = receivedMetadata.get(name);\n  if (!resolvedRangeInfo && metadataEntry) {\n    const metadata = metadataEntry.metadata;\n    const availableVersions = Object.keys(metadata.versions);\n    const versionsBeforeLock: string[] = [];\n    const versionsAfterLock: string[] = [];\n    const times = Object.entries(metadata.time)\n      .map(([version, timeStr]) => [version, new Date(timeStr as string)] as [string, Date])\n      .sort((e1, e2) => e1[1].getTime() - e2[1].getTime());\n    for (const [v, t] of times) {\n      if (metadata.versions[v]) {\n        if (t <= lockTime) {\n          versionsBeforeLock.push(v);\n        } else {\n          versionsAfterLock.push(v);\n        }\n      }\n    }\n\n    let version = semver.maxSatisfying(versionsBeforeLock, range, true);\n    if (!version) {\n      for (const v of versionsAfterLock) {\n        if (semver.satisfies(v, range, true)) {\n          version = v;\n          break;\n        }\n      }\n    }\n\n    if (!version) {\n      if (metadataEntry.fresh) {\n        throw new Error(\n          `Unable to resolve ${name}@${range}, ${metadata.name}, available versions: ${availableVersions}`,\n        );\n      }\n    } else {\n      let resolvedRanges = resolvedPackageRanges.get(name);\n      if (!resolvedRanges) {\n        resolvedRanges = new Map();\n        resolvedPackageRanges.set(name, resolvedRanges);\n      }\n      resolvedRangeInfo = { name, range, version };\n      resolvedRanges.set(range, resolvedRangeInfo);\n    }\n  }\n\n  if (!resolvedRangeInfo) {\n    let unresolvedRanges = unresolvedPackageRanges.get(name);\n    if (!unresolvedRanges) {\n      unresolvedRanges = new Set();\n      unresolvedPackageRanges.set(name, unresolvedRanges);\n\n      const requestedEntry = requestedMetadata.get(name);\n      if (!requestedEntry || !requestedEntry.fresh) {\n        requestedMetadata.set(name, { fresh: !!requestedEntry });\n\n        const event: ResolveEvent = { type: ResolveEventType.GET_METADATA, name };\n        if (!requestedEntry) {\n          event.lockTime = lockTime;\n        }\n\n        yield event;\n      }\n    }\n    unresolvedRanges.add(range);\n  }\n\n  return resolvedRangeInfo;\n};\n\nconst resolvePackage = function* ({\n  pkg,\n  id,\n  resolutionDependencies,\n  declaredPackageRanges,\n  unresolvedPackageRanges,\n  resolvedPackageRanges,\n  workspaceVersions,\n  requestedMetadata,\n  receivedMetadata,\n  lockTime,\n  state,\n  options,\n}: {\n  pkg: PurePackage;\n  id: string;\n  resolutionDependencies?: Map<string, string>;\n  declaredPackageRanges: DeclaredPackageRanges;\n  unresolvedPackageRanges: UnresolvedPackageRanges;\n  resolvedPackageRanges: ResolvedPackageRanges;\n  workspaceVersions: WorkspaceVersions;\n  requestedMetadata: RequestedMetadata;\n  receivedMetadata: ReceivedMetadata;\n  lockTime: Date;\n  state?: ResolveState;\n  options: ResolveOptions;\n}) {\n  if (declaredPackageRanges.has(id)) return;\n\n  const declaredRanges = new Map();\n  declaredPackageRanges.set(id, declaredRanges);\n\n  if (\n    !isPackageJsonFieldCompatible(options.cpu!, pkg.json.cpu) ||\n    !isPackageJsonFieldCompatible(options.os!, pkg.json.os) ||\n    !isPackageJsonFieldCompatible(options.libc!, pkg.json.libc)\n  ) {\n    return;\n  }\n\n  const dependencies = getDependencies(pkg.json, options.prod ? false : !!pkg.workspacePath);\n  const allDependencies = new Set<{ depName: string; depRange: string }>();\n  for (const [depName, depRange] of dependencies.regular) {\n    allDependencies.add({ depName, depRange });\n  }\n\n  if (options.autoInstallPeers) {\n    for (const [depName, depRange] of dependencies.peer) {\n      if (!dependencies.optionalPeerNames.has(depName)) {\n        allDependencies.add({ depName, depRange });\n      }\n    }\n  }\n\n  if (resolutionDependencies) {\n    for (const [depName, depRange] of resolutionDependencies) {\n      allDependencies.add({ depName, depRange });\n    }\n  }\n\n  for (const { depName, depRange } of allDependencies) {\n    const { name, range } = parseSpecifier(depName, depRange);\n\n    let ranges = declaredRanges.get(name);\n    if (!ranges) {\n      ranges = new Set();\n      declaredRanges.set(name, ranges);\n    }\n    ranges.add(range);\n\n    const resolvedRangeInfo = yield* resolveRange({\n      name,\n      range,\n      resolvedPackageRanges,\n      unresolvedPackageRanges,\n      workspaceVersions,\n      requestedMetadata,\n      receivedMetadata,\n      lockTime,\n      state,\n    });\n    if (resolvedRangeInfo) {\n      const { version, isWorkspace } = resolvedRangeInfo;\n\n      const childId = `${name}@${version}`;\n\n      if (!isWorkspace) {\n        const pkg = { json: receivedMetadata.get(name)!.metadata.versions[version] };\n\n        yield* resolvePackage({\n          pkg,\n          id: childId,\n          declaredPackageRanges,\n          unresolvedPackageRanges,\n          resolvedPackageRanges,\n          workspaceVersions,\n          requestedMetadata,\n          receivedMetadata,\n          lockTime,\n          state,\n          options,\n        });\n      }\n    }\n  }\n};\n\nconst resolveWorkspace = function* ({\n  pkg,\n  declaredPackageRanges,\n  unresolvedPackageRanges,\n  resolvedPackageRanges,\n  workspaceVersions,\n  requestedMetadata,\n  receivedMetadata,\n  lockTime,\n  state,\n  options,\n}: {\n  pkg: PurePackage;\n  declaredPackageRanges: DeclaredPackageRanges;\n  unresolvedPackageRanges: UnresolvedPackageRanges;\n  resolvedPackageRanges: ResolvedPackageRanges;\n  workspaceVersions: WorkspaceVersions;\n  requestedMetadata: RequestedMetadata;\n  receivedMetadata: ReceivedMetadata;\n  lockTime: Date;\n  state?: ResolveState;\n  options: ResolveOptions;\n}) {\n  const id = `${getWorkspaceName(pkg)}@${getWorkspaceVersion(pkg)}`;\n  yield* resolvePackage({\n    pkg,\n    id,\n    resolutionDependencies: getResolutionDependencies(pkg),\n    declaredPackageRanges,\n    unresolvedPackageRanges,\n    resolvedPackageRanges,\n    workspaceVersions,\n    requestedMetadata,\n    receivedMetadata,\n    lockTime,\n    state,\n    options,\n  });\n\n  if (pkg.workspaces) {\n    for (const workspace of pkg.workspaces) {\n      yield* resolveWorkspace({\n        pkg: workspace,\n        declaredPackageRanges,\n        unresolvedPackageRanges,\n        resolvedPackageRanges,\n        workspaceVersions,\n        requestedMetadata,\n        receivedMetadata,\n        lockTime,\n        state,\n        options,\n      });\n    }\n  }\n};\n\nconst createPackage = ({\n  pkg,\n  name,\n  version,\n  optional,\n  parentDependencyNames,\n  resolvedPackageRanges,\n  receivedMetadata,\n  nodeMap,\n  resolutionPath,\n  resolutions,\n  options,\n}: {\n  pkg: PurePackage;\n  name: string;\n  version: string;\n  optional: boolean;\n  parentDependencyNames: Set<string>;\n  resolvedPackageRanges: ResolvedPackageRanges;\n  receivedMetadata: ReceivedMetadata;\n  nodeMap: Map<string, Graph>;\n  resolutionPath: string;\n  resolutions: Map<string, string>;\n  options: ResolveOptions;\n}): Graph | null => {\n  if (\n    !pkg.workspacePath &&\n    (!isPackageJsonFieldCompatible(options.cpu!, pkg.json.cpu) ||\n      !isPackageJsonFieldCompatible(options.os!, pkg.json.os) ||\n      !isPackageJsonFieldCompatible(options.libc!, pkg.json.libc))\n  ) {\n    return null;\n  }\n\n  const { idProps, dependencies, peerNames, optionalNames } = assignId({\n    pkg,\n    name,\n    version,\n    parentDependencyNames,\n    resolutionPath,\n    resolutions,\n    options,\n  });\n  const graphId = stringifyGraphId(idProps);\n\n  let node: Graph | undefined;\n\n  if (!pkg.workspacePath) {\n    node = nodeMap.get(graphId);\n  }\n\n  if (node) {\n    if (!optional && node.optional) {\n      delete node.optional;\n    }\n\n    return node;\n  }\n\n  node = { id: graphId };\n  if (optional) {\n    node.optional = true;\n  }\n\n  if (pkg.workspacePath) {\n    node.workspacePath = pkg.workspacePath;\n  } else {\n    if (idProps.alias) {\n      node.alias = idProps.alias;\n    }\n  }\n\n  if (!pkg.workspacePath) {\n    nodeMap.set(graphId, node);\n  }\n\n  const tarballUrl = pkg.json?.dist?.tarball;\n  if (tarballUrl) {\n    node.tarballUrl = tarballUrl;\n  }\n\n  const buildScripts = getBuildScripts(pkg.json);\n  if (buildScripts) {\n    node.buildScripts = buildScripts;\n  }\n\n  const binType = typeof pkg.json.bin;\n  if (binType !== 'undefined') {\n    if (binType === 'string') {\n      node.bin = { [getPackageName(parseSpecifier(node.id).name)]: pkg.json.bin };\n    } else {\n      node.bin = pkg.json.bin;\n    }\n  }\n\n  const nextParentDependencyNames = new Set(parentDependencyNames);\n  for (const depName of dependencies.keys()) {\n    nextParentDependencyNames.add(depName);\n  }\n\n  if (dependencies.size > 0) {\n    node.dependencies = node.dependencies || [];\n    for (const [depName, depRange] of dependencies) {\n      const { name, range, alias } = parseSpecifier(depName, depRange);\n      const resolveMap = resolvedPackageRanges.get(name);\n      if (!resolveMap) {\n        throw new Error(`Unable to get resolve map for ${name}`);\n      }\n\n      const resolvedRangeInfo = resolveMap.get(range);\n      if (!resolvedRangeInfo) {\n        throw new Error(`Not found ${name}@${range} resolution used by ${graphId}`);\n      }\n      const { version, isWorkspace } = resolvedRangeInfo;\n\n      const pkg = isWorkspace\n        ? { json: { name: depName, version } }\n        : { json: receivedMetadata.get(name)!.metadata.versions[version] };\n      const depNode = createPackage({\n        pkg,\n        name: depName,\n        version: alias ? `npm:${alias}:${version}` : version,\n        optional: optional || optionalNames.has(depName),\n        parentDependencyNames: nextParentDependencyNames,\n        resolvedPackageRanges,\n        receivedMetadata,\n        nodeMap,\n        resolutions,\n        resolutionPath: getResolutionPath(depName, resolutionPath),\n        options,\n      });\n      if (depNode) {\n        node.dependencies.push(depNode);\n      }\n    }\n  }\n\n  if (peerNames.size > 0) {\n    node.peerNames = Array.from(peerNames);\n  }\n\n  return node;\n};\n\nconst createWorkspace = ({\n  pkg,\n  parentDependencyNames,\n  resolvedPackageRanges,\n  receivedMetadata,\n  nodeMap,\n  resolutionPath,\n  resolutions,\n  options,\n}: {\n  pkg: PurePackage;\n  parentDependencyNames: Set<string>;\n  resolvedPackageRanges: ResolvedPackageRanges;\n  receivedMetadata: ReceivedMetadata;\n  nodeMap: Map<string, Graph>;\n  resolutionPath: string;\n  resolutions: Map<string, string>;\n  options: ResolveOptions;\n}): Graph => {\n  const name = getWorkspaceName(pkg);\n  const version = getWorkspaceVersion(pkg);\n  const node = createPackage({\n    pkg,\n    name,\n    version,\n    optional: false,\n    resolvedPackageRanges,\n    receivedMetadata,\n    nodeMap,\n    parentDependencyNames,\n    resolutionPath,\n    resolutions,\n    options,\n  })!;\n\n  if (pkg.workspaces) {\n    node.workspaces = [];\n    for (const workspace of pkg.workspaces) {\n      node.workspaces.push(\n        createWorkspace({\n          pkg: workspace,\n          parentDependencyNames,\n          resolvedPackageRanges,\n          receivedMetadata,\n          nodeMap,\n          resolutions,\n          resolutionPath: getResolutionPath(getWorkspaceName(workspace), resolutionPath),\n          options,\n        }),\n      );\n    }\n  }\n\n  return node;\n};\n\nconst getResolutionDependencies = (node: PurePackage): Map<string, string> => {\n  const dependencies = new Map();\n\n  for (const [resolutionPath, range] of Object.entries<string>(node.json.resolutions || {})) {\n    const parts = resolutionPath.split('/');\n    if (parts.length === 1) {\n      dependencies.set(resolutionPath, range);\n    } else {\n      const nextToLast = parts[parts.length - 2];\n      if (nextToLast.startsWith('@')) {\n        dependencies.set([nextToLast, parts[parts.length - 1]].join('/'), range);\n      } else {\n        dependencies.set(parts[parts.length - 1], range);\n      }\n    }\n  }\n  return dependencies;\n};\n\nconst getWorkspaceResolutions = (node: PurePackage): Map<string, string> => {\n  const resolutions = new Map();\n  for (const [resolutionPath, range] of Object.entries<string>(node.json.resolutions || {})) {\n    const parts = resolutionPath.split('/');\n    const packageParts: string[] = [];\n    let scopePart;\n    for (const part of parts) {\n      if (part.startsWith('@')) {\n        scopePart = part;\n      } else {\n        if (scopePart) {\n          packageParts.push(`${scopePart}#${part}`);\n        } else {\n          packageParts.push(part);\n        }\n      }\n    }\n    resolutions.set(packageParts.join('/'), range);\n  }\n\n  return resolutions;\n};\n\nconst readWorkspaceVersions = ({ pkg }: { pkg: PurePackage }): WorkspaceVersions => {\n  const workspaceVersions: WorkspaceVersions = new Map();\n\n  const fillWorkspaceVersion = (workspace: PurePackage) => {\n    const name = getWorkspaceName(workspace);\n    let versions = workspaceVersions.get(name);\n    if (!versions) {\n      versions = new Set();\n      workspaceVersions.set(name, versions);\n    }\n    versions.add(getWorkspaceVersion(workspace));\n\n    if (workspace.workspaces) {\n      for (const nestedWorkspace of workspace.workspaces) {\n        fillWorkspaceVersion(nestedWorkspace);\n      }\n    }\n  };\n\n  fillWorkspaceVersion(pkg);\n\n  return workspaceVersions;\n};\n\nconst refineGraph = (node: Graph, seen: Set<Graph> = new Set()) => {\n  if (seen.has(node)) return;\n  seen.add(node);\n\n  if (node.dependencies) {\n    let totalLen = node.dependencies.length;\n    for (let idx = 0; idx < totalLen; idx++) {\n      const dep = node.dependencies[idx];\n      if (dep.id.startsWith('=')) {\n        node.dependencies.splice(idx, 1);\n        totalLen--;\n        idx--;\n      } else {\n        refineGraph(dep, seen);\n      }\n    }\n\n    if (totalLen === 0) {\n      delete node.dependencies;\n    }\n  }\n\n  if (node.workspaces) {\n    for (const dep of node.workspaces) {\n      refineGraph(dep, seen);\n    }\n  }\n};\n\nconst getMetadataMapFromStateAndOptions = ({\n  state,\n  options,\n}: {\n  state?: ResolveState;\n  options: ResolveOptions;\n}): ReceivedMetadata => {\n  const receivedMetadata = new Map();\n  if (state) {\n    for (const [name, { meta }] of state.resolutions) {\n      receivedMetadata.set(name, { metadata: meta, fresh: false });\n      if (options.verbose) {\n        console.log(`state>${name}`, JSON.stringify(meta));\n      }\n    }\n  }\n\n  if (options.receivedMetadata) {\n    for (const [name, metadata] of options.receivedMetadata) {\n      receivedMetadata.set(name, { metadata, fresh: true });\n      if (options.verbose) {\n        console.log(`opts>${name}`, JSON.stringify(metadata));\n      }\n    }\n  }\n\n  return receivedMetadata;\n};\n\nexport const resolveScript = function* (\n  pkg: PurePackage,\n  opts?: ResolveOptions,\n  prevState?: ResolveState,\n): Generator<ResolveEvent, ResolveResult, PackageMetadata | any> {\n  const options: ResolveOptions = opts || {};\n  options.cpu = options.cpu || process.arch;\n  options.os = options.os || process.platform;\n  options.libc = options.libc || getLibc();\n  let lockTime = pkg.json.lockTime ? new Date(pkg.json.lockTime) : new Date();\n  const declaredPackageRanges: DeclaredPackageRanges = new Map();\n  const unresolvedPackageRanges: UnresolvedPackageRanges = new Map();\n  const resolvedPackageRanges: ResolvedPackageRanges = new Map();\n  const state = prevState && new Date(prevState.lockTime).getTime() === lockTime.getTime() ? prevState : undefined;\n  const requestedMetadata: RequestedMetadata = new Map();\n  const receivedMetadata = getMetadataMapFromStateAndOptions({ state, options });\n\n  const workspaceVersions = readWorkspaceVersions({ pkg });\n  yield* resolveWorkspace({\n    pkg,\n    declaredPackageRanges,\n    unresolvedPackageRanges,\n    resolvedPackageRanges,\n    requestedMetadata,\n    receivedMetadata,\n    workspaceVersions,\n    lockTime,\n    state,\n    options,\n  });\n\n  while (unresolvedPackageRanges.size !== 0) {\n    const packageMetadata = yield { type: ResolveEventType.NEXT_METADATA };\n    if (!packageMetadata) {\n      throw new Error('Unable to receive packages metadata, aborting...');\n    }\n    const depName = packageMetadata.name;\n    if (packageMetadata.fresh) {\n      requestedMetadata.set(depName, { fresh: true });\n    }\n\n    receivedMetadata.set(depName, packageMetadata);\n    if (options.verbose) {\n      console.log(`net>${packageMetadata.name}`, JSON.stringify(packageMetadata.metadata));\n    }\n    const unresolvedRanges = unresolvedPackageRanges.get(depName);\n    let resolvedRanges = resolvedPackageRanges.get(depName);\n    if (!resolvedRanges) {\n      resolvedRanges = new Map();\n      resolvedPackageRanges.set(depName, resolvedRanges);\n    }\n\n    if (unresolvedRanges) {\n      do {\n        const unresolvedRange = unresolvedRanges.values().next().value as string;\n        const resolvedRangeInfo = yield* resolveRange({\n          name: depName,\n          range: unresolvedRange,\n          resolvedPackageRanges,\n          unresolvedPackageRanges,\n          requestedMetadata,\n          receivedMetadata,\n          lockTime,\n          state,\n        });\n        if (resolvedRangeInfo) {\n          const version = resolvedRangeInfo.version;\n          resolvedRanges.set(unresolvedRange, resolvedRangeInfo);\n\n          unresolvedRanges.delete(unresolvedRange);\n          const json = packageMetadata.metadata.versions[version];\n          const childId = `${depName}@${version}`;\n\n          yield* resolvePackage({\n            pkg: { json },\n            id: childId,\n            declaredPackageRanges,\n            unresolvedPackageRanges,\n            resolvedPackageRanges,\n            workspaceVersions,\n            requestedMetadata,\n            receivedMetadata,\n            lockTime,\n            state,\n            options,\n          });\n        } else {\n          break;\n        }\n      } while (unresolvedRanges.size);\n\n      if (unresolvedRanges.size === 0) {\n        unresolvedPackageRanges.delete(depName);\n      }\n    }\n  }\n\n  orderResolvedRanges(resolvedPackageRanges);\n\n  if (options.resolutionOptimization) {\n    optimizeResolutions({ workspaceVersions, declaredPackageRanges, resolvedPackageRanges, options });\n  }\n\n  const nodeMap = new Map();\n  const graph = createWorkspace({\n    pkg,\n    parentDependencyNames: new Set(),\n    resolvedPackageRanges,\n    receivedMetadata,\n    nodeMap,\n    resolutionPath: getResolutionPath(getWorkspaceName(pkg)),\n    resolutions: getWorkspaceResolutions(pkg),\n    options,\n  });\n\n  refineGraph(graph);\n\n  if (options.dump) {\n    console.log(print(graph));\n  }\n\n  const nextState = getState({ resolvedPackageRanges, receivedMetadata, lockTime });\n\n  let result: ResolveResult = { graph };\n  if (nextState) {\n    result.state = nextState;\n  }\n\n  return result;\n};\n\nconst minimizeJson = (json: any): any => {\n  const result: any = {};\n\n  for (const key of Object.keys(json)) {\n    if (\n      [\n        'bin',\n        'os',\n        'cpu',\n        'libc',\n        'dependencies',\n        'optionalDependencies',\n        'peerDependencies',\n        'peerDependenciesMeta',\n      ].indexOf(key) >= 0\n    ) {\n      result[key] = json[key];\n    }\n  }\n\n  if (json.scripts) {\n    for (const scriptName of Object.keys(json.scripts)) {\n      if (BUILD_SCRIPTS.indexOf(scriptName) >= 0) {\n        if (!result.scripts) {\n          result.scripts = {};\n        }\n        result.scripts[scriptName] = json.scripts[scriptName];\n      }\n    }\n  }\n\n  return result;\n};\n\nconst minimizeMetadata = (metadata: any, versions: Set<string>): any => {\n  const result = { versions: {}, time: {} };\n  for (const version of versions) {\n    result.versions[version] = minimizeJson(metadata.versions[version]);\n    result.time[version] = metadata.time[version];\n  }\n\n  return result;\n};\n\nconst orderResolvedRanges = (resolvedPackageRanges: ResolvedPackageRanges) => {\n  const originalResolveRanges = new Map(resolvedPackageRanges);\n  resolvedPackageRanges.clear();\n\n  const sortedNames = Array.from(originalResolveRanges.keys()).sort();\n  for (const name of sortedNames) {\n    const resolveMap = originalResolveRanges.get(name)!;\n    const originalResolveMap = new Map(resolveMap);\n    resolveMap.clear();\n\n    const sortedRanges = Array.from(originalResolveMap.keys()).sort();\n    for (const range of sortedRanges) {\n      resolveMap.set(range, originalResolveMap.get(range)!);\n    }\n\n    resolvedPackageRanges.set(name, resolveMap);\n  }\n};\n\nconst getState = ({\n  resolvedPackageRanges,\n  receivedMetadata,\n  lockTime,\n}: {\n  resolvedPackageRanges: ResolvedPackageRanges;\n  receivedMetadata: ReceivedMetadata;\n  lockTime: Date;\n}): ResolveState | undefined => {\n  const resolutions: Resolutions = new Map();\n\n  for (const [name, resolveMap] of resolvedPackageRanges) {\n    const ranges = new Map();\n    const versions: string[] = [];\n    for (const [range, { isWorkspace, version }] of resolveMap) {\n      if (isWorkspace) continue;\n\n      ranges.set(range, version);\n      versions.push(version);\n    }\n\n    if (ranges.size > 0) {\n      const metadataEntry = receivedMetadata.get(name);\n      if (metadataEntry) {\n        const meta = minimizeMetadata(metadataEntry.metadata, new Set(versions));\n        resolutions.set(name, { meta, ranges });\n      }\n    }\n  }\n\n  return resolutions.size > 0 ? { resolutions, lockTime } : undefined;\n};\n\nconst optimizeResolutions = ({\n  workspaceVersions,\n  declaredPackageRanges,\n  resolvedPackageRanges,\n  options,\n}: {\n  workspaceVersions: WorkspaceVersions;\n  declaredPackageRanges: DeclaredPackageRanges;\n  resolvedPackageRanges: ResolvedPackageRanges;\n  options: ResolveOptions;\n}) => {\n  let shouldOptimizeAgain;\n\n  do {\n    shouldOptimizeAgain = false;\n\n    for (const [name, resolveMap] of resolvedPackageRanges) {\n      const resolveInfoSet = new Set(resolveMap.values());\n      const hasNonCaret = Array.from(resolveMap.keys()).find((x) => !/^\\^[0-9]+\\.[0-9]+\\.[0-9]+$/.test(x));\n\n      if (resolveInfoSet.size === 1 || !hasNonCaret) {\n        continue;\n      }\n\n      let versionToRanges = new Map<string, Set<string>>();\n      let rangesToVersion = new Map<string, Set<string>>();\n      const versionList = new Set(Array.from(resolveMap.values()).map((x) => x.version));\n      for (const version of versionList) {\n        const matchedRanges = new Set<string>();\n        versionToRanges.set(version, matchedRanges);\n        for (const [checkRange, { version: checkVersion }] of resolveMap) {\n          if (version === checkVersion || semver.satisfies(version, checkRange, true)) {\n            matchedRanges.add(checkRange);\n            let matchedVersions = rangesToVersion.get(checkRange);\n            if (!matchedVersions) {\n              matchedVersions = new Set();\n              rangesToVersion.set(checkRange, matchedVersions);\n            }\n            matchedVersions.add(version);\n          }\n        }\n      }\n\n      const unmatchedRanges = new Set(resolveMap.keys());\n      const versions: string[] = [];\n      while (unmatchedRanges.size > 0) {\n        let bestCoverVersion: string | undefined, bestMatchedRanges: Set<string> | undefined;\n        for (const [version, matchedRanges] of versionToRanges) {\n          if (!bestCoverVersion || versionToRanges.get(bestCoverVersion)!.size < matchedRanges.size) {\n            bestCoverVersion = version;\n            bestMatchedRanges = matchedRanges;\n          }\n        }\n\n        versions.push(bestCoverVersion!);\n        versionToRanges.delete(bestCoverVersion!);\n\n        for (const range of bestMatchedRanges!) {\n          unmatchedRanges.delete(range);\n          rangesToVersion.get(range)!.delete(bestCoverVersion!);\n        }\n      }\n\n      for (const [range, rangeInfo] of resolveMap) {\n        const { version: originalVersion } = rangeInfo;\n        const version = semver.maxSatisfying(versions, range, true)!;\n        if (version === originalVersion) continue;\n\n        if (options.traceRangeUsages) {\n          console.log(`rewire ${name}@${range} from ${originalVersion} to ${version}`);\n        }\n\n        shouldOptimizeAgain = true;\n\n        rangeInfo.version = version;\n      }\n    }\n\n    const usedPackageRanges = new Map<string, Set<string>>();\n\n    const addRangeUsages = (packageId: string, seen: Set<string>) => {\n      if (seen.has(packageId)) return;\n      seen.add(packageId);\n\n      const declaredRanges = declaredPackageRanges.get(packageId);\n      if (!declaredRanges) {\n        throw new Error(`No declared ranges for ${packageId}`);\n      }\n\n      for (const [name, ranges] of declaredRanges) {\n        let usedRanges = usedPackageRanges.get(name);\n        if (!usedRanges) {\n          usedRanges = new Set();\n          usedPackageRanges.set(name, usedRanges);\n        }\n        for (const range of ranges) {\n          usedRanges.add(range);\n          const resolveMap = resolvedPackageRanges.get(name)!;\n          const { version } = resolveMap.get(range)!;\n          addRangeUsages(`${name}@${version}`, seen);\n        }\n      }\n    };\n\n    const seen = new Set<string>();\n    for (const [name, versions] of workspaceVersions) {\n      for (const version of versions) {\n        addRangeUsages(`${name}@${version}`, seen);\n      }\n    }\n\n    for (const [name, resolveMap] of resolvedPackageRanges) {\n      const usedRanges = usedPackageRanges.get(name);\n      if (!usedRanges) {\n        if (options.traceRangeUsages) {\n          console.log(`delete all versions for package ${name}`);\n        }\n        resolvedPackageRanges.delete(name);\n        continue;\n      }\n\n      for (const [range, rangeInfo] of resolveMap) {\n        if (!usedRanges.has(range)) {\n          if (options.traceRangeUsages) {\n            console.log(`delete ${name}@${rangeInfo.range}`);\n          }\n          resolveMap.delete(range);\n        }\n      }\n    }\n  } while (shouldOptimizeAgain);\n};\n\nexport const getBuildScripts = (json: any): Record<string, string> | undefined => {\n  const buildScripts = {};\n\n  for (const [scriptName, script] of Object.entries(json.scripts || {})) {\n    if (BUILD_SCRIPTS.indexOf(scriptName) >= 0) {\n      buildScripts[scriptName] = script;\n    }\n  }\n\n  return Object.entries(buildScripts).length > 0 ? buildScripts : undefined;\n};\n\nconst getPackageName = (name: string) => {\n  const idx = name.indexOf('/');\n  return idx < 0 ? name : name.substring(idx + 1);\n};\n\nexport const parseSpecifier = (\n  fullSpecifier: string,\n  specifierRange?: string,\n): { name: string; range: string; alias: string } => {\n  let name, range;\n  let ignoreIdx = fullSpecifier.indexOf('>');\n  if (ignoreIdx < 0) {\n    ignoreIdx = fullSpecifier.indexOf('#');\n  }\n  if (ignoreIdx < 0) {\n    ignoreIdx = fullSpecifier.indexOf('|');\n  }\n  const specifier = ignoreIdx < 0 ? fullSpecifier : fullSpecifier.substring(0, ignoreIdx);\n\n  const idx = specifier.indexOf(`@`, 1);\n  if (idx < 0) {\n    name = specifier;\n    range = specifierRange || '';\n  } else {\n    name = specifier.substring(0, idx);\n    range = specifier.substring(idx + 1);\n    if (specifierRange) {\n      throw new Error(`Unclear specification. Specifier: ${specifier}, range: ${specifierRange}`);\n    }\n  }\n\n  if (!range.startsWith('npm:')) return { name, range, alias: '' };\n\n  const realSpecifier = range.substring(4);\n  const realIdx = realSpecifier.indexOf(`@`, 1);\n  if (realIdx < 0) return { name: realSpecifier, range: '', alias: name };\n\n  return { name: realSpecifier.substring(0, realIdx), range: realSpecifier.substring(realIdx + 1), alias: name };\n};\n\nconst getResolutionPath = (name: string, parentResolutionPath?: string) =>\n  (parentResolutionPath ? [parentResolutionPath] : []).concat(name.replaceAll('/', '#')).join('/');\nconst getResolutionRange = ({\n  resolutions,\n  resolutionPath,\n  depRange,\n}: {\n  resolutions: Map<string, string>;\n  resolutionPath: string;\n  depRange: string;\n}): { range: string; resolution?: string } => {\n  let range = depRange;\n  for (const [resolution, resolutionRange] of resolutions) {\n    if (resolutionPath.endsWith(resolution)) {\n      return { range: resolutionRange, resolution };\n    }\n  }\n\n  return { range };\n};\n\nconst print = (graph: Graph): string => {\n  const seen = new Map();\n\n  const printDependency = (node: Graph, { depPrefix, suffix }: { depPrefix: string; suffix: string }): string => {\n    let str = depPrefix;\n    if (node.workspacePath) {\n      str += 'workspace:';\n    } else if (node.packageType === PackageType.PORTAL) {\n      str += 'portal:';\n    }\n\n    str += node.id;\n    if (node.wall) {\n      str += '|';\n      if (node.wall.length > 0) {\n        str += Array.from(node.wall);\n      }\n    }\n    str += `(${suffix})`;\n    str += '\\n';\n\n    return str;\n  };\n\n  const visitDependency = (node: Graph, { prefix, depPrefix }: { prefix: string; depPrefix: string }): string => {\n    const seq = seen.get(node);\n    let str = printDependency(node, { depPrefix, suffix: seq ? seq + '*' : seen.size + '' });\n    if (seq) return str;\n\n    seen.set(node, seen.size);\n\n    const deps: Graph[] = [];\n    if (node.workspaces) {\n      for (const dep of node.workspaces.values()) {\n        deps.push(dep);\n      }\n    }\n\n    if (node.dependencies) {\n      for (const dep of node.dependencies) {\n        deps.push(dep);\n      }\n    }\n\n    for (let idx = 0; idx < deps.length; idx++) {\n      const dep = deps[idx];\n      const hasMoreDependencies = idx < deps.length - 1;\n      str += visitDependency(dep, {\n        depPrefix: prefix + (hasMoreDependencies ? `\u251C\u2500` : `\u2514\u2500`),\n        prefix: prefix + (hasMoreDependencies ? `\u2502 ` : `  `),\n      });\n    }\n\n    return str;\n  };\n\n  return visitDependency(graph, { prefix: '  ', depPrefix: '' }).trim();\n};\n", "export type Dependencies = {\n  regular: Map<string, string>;\n  regularType: Map<string, DependencyType>;\n  peer: Map<string, string>;\n  optionalNames: Set<string>;\n  optionalPeerNames: Set<string>;\n};\n\nexport enum DependencyType {\n  DEPENDENCIES = 'dependencies',\n  DEV_DEPENDENCIES = 'devDependencies',\n  PEER_DEPENDENCIES = 'peerDependencies',\n  OPTIONAL_DEPENDENCIES = 'optionalDependencies',\n}\n\n// eslint-disable-next-line no-redeclare\nexport const Dependencies = {\n  EMPTY: {\n    regular: new Map(),\n    regularType: new Map(),\n    peer: new Map(),\n    optionalNames: new Set(),\n    optionalPeerNames: new Set(),\n  } as Dependencies,\n};\n\nexport const getDependencies = (packageJson: any, includeDev?: boolean): Dependencies => {\n  const regular = new Map();\n  const regularType = new Map();\n  const peer = new Map();\n  const optionalPeerNames = new Set<string>();\n  const optionalNames = new Set<string>();\n\n  for (const [name, range] of Object.entries<string>(packageJson.dependencies || {})) {\n    regular.set(name, range);\n    regularType.set(name, DependencyType.DEPENDENCIES);\n  }\n\n  for (const [name, range] of Object.entries<string>(packageJson.optionalDependencies || {})) {\n    optionalNames.add(name);\n    regular.set(name, range);\n    regularType.set(name, DependencyType.OPTIONAL_DEPENDENCIES);\n  }\n\n  if (includeDev) {\n    for (const [name, range] of Object.entries<string>(packageJson.devDependencies || {})) {\n      regular.set(name, range);\n      regularType.set(name, DependencyType.DEV_DEPENDENCIES);\n    }\n  }\n\n  for (const [name, range] of Object.entries<string>(packageJson.peerDependencies || {})) {\n    peer.set(name, range);\n  }\n\n  for (const [name, value] of Object.entries<any>(packageJson.peerDependenciesMeta || {})) {\n    if (value.optional === true && peer.has(name)) {\n      optionalPeerNames.add(name);\n    }\n  }\n\n  return { regular, regularType, peer, optionalPeerNames, optionalNames };\n};\n", "import { PackageName, WorkGraph, fromAliasedId, printGraphPath } from './hoist';\n\nexport enum Hoistable {\n  LATER = 'LATER',\n  YES = 'YES',\n  DEPENDS = 'DEPENDS',\n}\n\nexport type HoistingDecision =\n  | {\n      isHoistable: Hoistable.LATER;\n      queueIndex: number;\n    }\n  | {\n      isHoistable: Hoistable.YES;\n      newParentIndex: number;\n      reason?: string;\n    }\n  | {\n      isHoistable: Hoistable.DEPENDS;\n      dependsOn: Set<PackageName>;\n      newParentIndex: number;\n      reason?: string;\n    };\n\nexport type FinalDecisions = {\n  decisionMap: Map<PackageName, HoistingDecision>;\n  circularPackageNames: Set<PackageName>;\n};\n\nexport type DecisionMap = Map<PackageName, HoistingDecision>;\n\ntype DecisionOptions = {\n  trace?: boolean;\n};\n\nexport const getHoistingDecision = (\n  graphPath: WorkGraph[],\n  depName: PackageName,\n  currentPriorityDepth: number,\n): HoistingDecision => {\n  const parentPkg = graphPath[graphPath.length - 1];\n  const dep = parentPkg.dependencies!.get(depName)!;\n  const realDepId = fromAliasedId(dep.id).id;\n  let isHoistable = Hoistable.YES;\n  const dependsOn = new Set<PackageName>();\n  let priorityDepth = 0;\n  let newParentIndex;\n  let reason;\n\n  let waterMark = 0;\n  for (let idx = graphPath.length - 1; idx >= 0; idx--) {\n    const newParentPkg = graphPath[idx];\n\n    const newParentDep = newParentPkg.dependencies?.get(depName);\n    if (newParentDep && newParentDep.id !== dep.id) {\n      waterMark = idx + 1;\n      if (newParentDep.queueIndex && waterMark !== graphPath.length - 1) {\n        isHoistable = Hoistable.LATER;\n        priorityDepth = newParentDep.queueIndex;\n      } else {\n        reason = `${dep.id} is blocked by a conflicting dependency ${newParentDep.id} at ${printGraphPath(\n          graphPath.slice(0, idx + 1),\n        )}`;\n      }\n      break;\n    }\n\n    if (newParentPkg.wall && (newParentPkg.wall.size === 0 || newParentPkg.wall.has(depName))) {\n      waterMark = idx;\n      reason = `${dep.id} is blocked by the hoisting wall at ${newParentPkg.id}`;\n      break;\n    }\n  }\n\n  if (isHoistable === Hoistable.YES) {\n    for (let idx = graphPath.length - 2; idx >= waterMark; idx--) {\n      const newParentPkg = graphPath[idx];\n\n      let hasBinConflicts = false;\n      for (const scriptName of dep.ownBinEntries) {\n        const pkgId = newParentPkg.binEntries.get(scriptName);\n        if (pkgId && pkgId !== realDepId) {\n          waterMark = idx + 1;\n          reason = `${dep.id} is blocked by the coflicting bin script ${scriptName} from ${pkgId} at ${newParentPkg.id}`;\n          hasBinConflicts = true;\n          break;\n        }\n      }\n\n      if (hasBinConflicts) {\n        break;\n      }\n    }\n  }\n\n  if (isHoistable === Hoistable.YES) {\n    // Check require contract\n    for (newParentIndex = waterMark; newParentIndex < graphPath.length - 1; newParentIndex++) {\n      const newParentPkg = graphPath[newParentIndex];\n\n      const newParentDep = newParentPkg.dependencies?.get(depName);\n      if (!newParentPkg.hoistingPriorities.get(depName)) {\n        console.log(\n          depName,\n          graphPath.map((n) => n.id),\n          parentPkg.dependencies?.get('@gqlapp/look-client-react')?.workspace?.id,\n          parentPkg.dependencies?.get('@gqlapp/look-client-react')?.workspace ===\n            parentPkg.dependencies?.get('@gqlapp/look-client-react'),\n        );\n      }\n      priorityDepth = newParentPkg.hoistingPriorities.get(depName)!.indexOf(dep.id);\n      if (!newParentDep) {\n        const isDepTurn = priorityDepth <= currentPriorityDepth;\n        if (!isDepTurn) {\n          isHoistable = Hoistable.LATER;\n          break;\n        }\n      }\n\n      let canBeHoisted = true;\n      if (dep.dependencies) {\n        for (const [hoistedName, hoistedDep] of dep.dependencies) {\n          if (hoistedDep.newParent) {\n            const originalId = hoistedDep.id;\n            const availableId = newParentPkg.dependencies!.get(hoistedName)?.id;\n\n            if (availableId !== originalId) {\n              canBeHoisted = false;\n              reason = `hoisting ${dep.id} to ${printGraphPath(\n                graphPath.slice(0, newParentIndex + 1),\n              )} will result in usage of ${availableId || \"'none'\"} instead of ${originalId}`;\n              break;\n            }\n          }\n        }\n      }\n\n      if (canBeHoisted) {\n        break;\n      }\n    }\n  }\n\n  // Check peer dependency contract\n  if (isHoistable === Hoistable.YES) {\n    if (dep.peerNames) {\n      for (const peerName of dep.peerNames.keys()) {\n        if (peerName !== depName) {\n          let peerParent;\n          let peerParentIdx;\n          for (let idx = graphPath.length - 1; idx >= 0; idx--) {\n            if (!graphPath[idx].peerNames?.has(peerName)) {\n              peerParentIdx = idx;\n              peerParent = graphPath[idx];\n              break;\n            }\n          }\n\n          const peerDep = peerParent.dependencies?.get(peerName);\n\n          if (peerDep) {\n            const depPriority = graphPath[newParentIndex].hoistingPriorities.get(depName)!.indexOf(dep.id);\n            if (depPriority <= currentPriorityDepth) {\n              if (peerParentIdx === graphPath.length - 1) {\n                // Might be a cyclic peer dependency, mark that we depend on it\n                isHoistable = Hoistable.DEPENDS;\n                dependsOn.add(peerName);\n              } else {\n                if (peerParentIdx > newParentIndex) {\n                  newParentIndex = peerParentIdx;\n                  reason = `unable to hoist ${dep.id} over peer dependency ${printGraphPath(\n                    graphPath.slice(0, newParentIndex + 1).concat([peerDep]),\n                  )}`;\n                }\n              }\n            } else {\n              // Should be hoisted later, wait\n              isHoistable = Hoistable.LATER;\n              priorityDepth = Math.max(priorityDepth, depPriority);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (isHoistable === Hoistable.LATER) {\n    return { isHoistable, queueIndex: priorityDepth };\n  } else if (isHoistable === Hoistable.DEPENDS) {\n    const result: HoistingDecision = { isHoistable, dependsOn, newParentIndex };\n    if (reason) {\n      result.reason = reason;\n    }\n    return result;\n  } else {\n    const result: HoistingDecision = { isHoistable: Hoistable.YES, newParentIndex };\n    if (reason) {\n      result.reason = reason;\n    }\n    return result;\n  }\n};\n\nexport const finalizeDependedDecisions = (\n  graphPath: WorkGraph[],\n  preliminaryDecisionMap: DecisionMap,\n  opts?: DecisionOptions,\n): FinalDecisions => {\n  const parentPkg = graphPath[graphPath.length - 1];\n  const options = opts || { trace: false };\n\n  const finalDecisions: FinalDecisions = {\n    decisionMap: new Map(),\n    circularPackageNames: new Set(),\n  };\n\n  const dependsOn = new Map<PackageName, Set<PackageName>>();\n  const getRecursiveDependees = (dependant: PackageName, seen: Set<PackageName>): Set<PackageName> => {\n    const dependees = new Set<PackageName>();\n    if (seen.has(dependant)) return dependees;\n    seen.add(dependant);\n\n    const decision = preliminaryDecisionMap.get(dependant);\n    if (decision && decision.isHoistable === Hoistable.DEPENDS) {\n      for (const dependee of decision.dependsOn) {\n        dependees.add(dependee);\n\n        const nestedDependees = getRecursiveDependees(dependee, seen);\n        for (const nestedDependee of nestedDependees) {\n          dependees.add(nestedDependee);\n        }\n      }\n    }\n\n    dependees.delete(dependant);\n    return dependees;\n  };\n\n  for (const [dependantName, decision] of preliminaryDecisionMap) {\n    if (decision.isHoistable === Hoistable.DEPENDS) {\n      const dependees = getRecursiveDependees(dependantName, new Set());\n      dependsOn.set(dependantName, dependees);\n\n      const dependeesArray = Array.from(dependees);\n      for (let idx = dependeesArray.length - 1; idx >= 0; idx--) {\n        const dependee = dependeesArray[idx];\n        const dependeeDecision = preliminaryDecisionMap.get(dependee);\n        if (dependeeDecision && !finalDecisions.decisionMap.has(dependee)) {\n          finalDecisions.decisionMap.set(dependee, dependeeDecision);\n        }\n      }\n    } else {\n      finalDecisions.decisionMap.set(dependantName, decision);\n    }\n  }\n\n  for (const [dependantName, dependees] of dependsOn) {\n    const originalDecision = preliminaryDecisionMap.get(dependantName)!;\n    if (originalDecision.isHoistable === Hoistable.DEPENDS) {\n      let isHoistable: Hoistable = originalDecision.isHoistable;\n      let priorityDepth = 0;\n      let newParentIndex: number = originalDecision.newParentIndex;\n      let reason: string | undefined = originalDecision.reason;\n      for (const dependeeName of dependees) {\n        const dependeeDecision = preliminaryDecisionMap.get(dependeeName);\n        if (dependeeDecision) {\n          if (dependeeDecision.isHoistable === Hoistable.LATER) {\n            isHoistable = Hoistable.LATER;\n            priorityDepth = Math.max(priorityDepth, dependeeDecision.queueIndex);\n          } else if (isHoistable !== Hoistable.LATER) {\n            if (dependeeDecision.isHoistable === Hoistable.YES) {\n              isHoistable = Hoistable.YES;\n            }\n            if (dependeeDecision.newParentIndex > newParentIndex) {\n              newParentIndex = dependeeDecision.newParentIndex;\n              reason = `peer dependency was not hoisted, due to ${dependeeDecision.reason}`;\n            }\n          }\n        }\n      }\n\n      if (isHoistable !== Hoistable.DEPENDS || newParentIndex > originalDecision.newParentIndex) {\n        let finalDecision: HoistingDecision;\n        if (isHoistable === Hoistable.LATER) {\n          finalDecision = { isHoistable, queueIndex: priorityDepth };\n        } else if (isHoistable === Hoistable.YES) {\n          finalDecision = { isHoistable, newParentIndex };\n          if (reason) {\n            finalDecision.reason = reason;\n          }\n        } else {\n          finalDecision = { isHoistable, newParentIndex, dependsOn: originalDecision.dependsOn };\n          if (reason) {\n            finalDecision.reason = reason;\n          }\n        }\n        finalDecisions.decisionMap.set(dependantName, finalDecision);\n      }\n    }\n  }\n\n  for (const depName of finalDecisions.decisionMap.keys()) {\n    const decision = finalDecisions.decisionMap.get(depName)!;\n    if (decision.isHoistable === Hoistable.DEPENDS) {\n      finalDecisions.circularPackageNames.add(depName);\n    }\n  }\n\n  if (options.trace) {\n    const prettifyDecision = (decision: HoistingDecision): any => ({\n      ...decision,\n      isHoistable:\n        decision.isHoistable !== Hoistable.YES || decision.newParentIndex !== graphPath.length - 1\n          ? decision.isHoistable.toString()\n          : 'NO',\n    });\n\n    for (const depName of Array.from(finalDecisions.decisionMap.keys()).sort()) {\n      const decision = finalDecisions.decisionMap.get(depName)!;\n      const preliminaryDecision = preliminaryDecisionMap.get(depName)!;\n      const args: any[] = [parentPkg.dependencies?.get(depName)?.id, prettifyDecision(preliminaryDecision)];\n      if (preliminaryDecision !== decision) {\n        args.push('finalized:');\n        args.push(prettifyDecision(decision));\n      }\n      console.log(...args);\n    }\n  }\n\n  return finalDecisions;\n};\n", "import { PackageId, PackageName, PackageType, WorkGraph, getPackageName } from './hoist';\n\nexport type HoistingPriorities = Map<PackageName, PackageId[]>;\nexport type Usages = Map<PackageId, Set<PackageId>>;\nexport type Children = Map<PackageId, { internalPriority: number; userPriority: number }>;\n\nexport const getUsages = (graph: WorkGraph): Usages => {\n  const packageUsages = new Map();\n  const seen = new Set();\n\n  const visitDependency = (graphPath: WorkGraph[]) => {\n    const pkg = graphPath[graphPath.length - 1];\n    let usedBy = packageUsages.get(pkg.id);\n    let isSeen = false;\n    if (!pkg.workspace || pkg.workspace !== pkg) {\n      isSeen = seen.has(pkg.id);\n      seen.add(pkg.id);\n\n      if (!usedBy) {\n        usedBy = new Set();\n        packageUsages.set(pkg.id, usedBy);\n      }\n\n      if (graphPath.length > 1) {\n        usedBy.add(graphPath[graphPath.length - 2].id);\n      }\n    }\n\n    if (pkg.peerNames) {\n      for (const peerName of pkg.peerNames.keys()) {\n        let peerDep;\n        for (let idx = graphPath.length - 2; idx >= 0; idx--) {\n          peerDep = graphPath[idx].dependencies?.get(peerName);\n          if (peerDep) {\n            let usedBy = packageUsages.get(peerDep.id);\n            if (!usedBy) {\n              usedBy = new Set();\n              packageUsages.set(peerDep.id, usedBy);\n            }\n            usedBy.add(pkg.id);\n            break;\n          }\n        }\n      }\n    }\n\n    if (pkg.workspaces) {\n      for (const dep of pkg.workspaces.values()) {\n        graphPath.push(dep);\n        visitDependency(graphPath);\n        graphPath.pop();\n      }\n    }\n\n    if (!isSeen) {\n      if (pkg.dependencies) {\n        for (const dep of pkg.dependencies.values()) {\n          graphPath.push(dep);\n          visitDependency(graphPath);\n          graphPath.pop();\n        }\n      }\n    }\n  };\n\n  visitDependency([graph]);\n\n  return packageUsages;\n};\n\nexport const getChildren = (graph: WorkGraph): Children => {\n  const children: Children = new Map();\n\n  const visitDependency = (graphPath: WorkGraph[]) => {\n    const pkg = graphPath[graphPath.length - 1];\n    let isSeen = false;\n\n    if (!pkg.workspace || pkg.workspace !== pkg) {\n      let pkgPriority = children.get(pkg.id);\n      isSeen = typeof pkgPriority !== 'undefined';\n      pkgPriority = pkgPriority || { internalPriority: 0, userPriority: 0 };\n\n      if (graphPath.length > 1) {\n        const parent = graphPath[graphPath.length - 2];\n        let priority = 0;\n        if (parent.workspace === parent) {\n          priority = 1;\n        } else if (parent.packageType === PackageType.PORTAL) {\n          priority = 2;\n        }\n        children.set(pkg.id, {\n          internalPriority: Math.max(pkgPriority.internalPriority, priority),\n          userPriority: Math.max(pkgPriority.userPriority, pkg.priority || 0),\n        });\n      }\n    }\n\n    if (pkg.workspaces) {\n      for (const dep of pkg.workspaces.values()) {\n        graphPath.push(dep);\n        visitDependency(graphPath);\n        graphPath.pop();\n      }\n    }\n\n    if (!isSeen) {\n      if (pkg.dependencies) {\n        for (const dep of pkg.dependencies.values()) {\n          if (!dep.newParent || dep.newParent === pkg) {\n            graphPath.push(dep);\n            visitDependency(graphPath);\n            graphPath.pop();\n          }\n        }\n      }\n    }\n  };\n\n  visitDependency([graph]);\n\n  return children;\n};\n\nexport const getPriorities = (usages: Usages, children: Children): HoistingPriorities => {\n  const priorities = new Map();\n\n  const pkgIds = Array.from(children.keys());\n  pkgIds.sort((id1, id2) => {\n    const priority1 = children.get(id1)!;\n    const priority2 = children.get(id2)!;\n    if (priority2.internalPriority !== priority1.internalPriority) {\n      return priority2.internalPriority - priority1.internalPriority;\n    } else if (priority2.userPriority !== priority1.userPriority) {\n      return priority2.userPriority - priority1.userPriority;\n    } else {\n      const usage1 = usages.get(id1)!.size;\n      const usage2 = usages.get(id2)!.size;\n      if (usage2 !== usage1) {\n        return usage2 - usage1;\n      } else {\n        return id2 > id1 ? -1 : 1;\n      }\n    }\n  });\n\n  for (const pkgId of pkgIds) {\n    const pkgName = getPackageName(pkgId);\n    let priorityList = priorities.get(pkgName);\n    if (!priorityList) {\n      priorityList = [];\n      priorities.set(pkgName, priorityList);\n    }\n    priorityList.push(pkgId);\n  }\n\n  return priorities;\n};\n", "import { PackageId, WorkGraph, fromAliasedId, GraphRoute } from './hoist';\n\nexport type WorkspaceUsageRoutes = Map<PackageId, Set<GraphRoute>>;\n\nexport const getWorkspaceNodes = (graph: WorkGraph): Map<PackageId, WorkGraph> => {\n  const workspaceNodes = new Map<PackageId, WorkGraph>();\n  const visitWorkspace = (workspace: WorkGraph) => {\n    workspaceNodes.set(workspace.id, workspace);\n    if (workspace.workspaces) {\n      for (const dep of workspace.workspaces.values()) {\n        visitWorkspace(dep);\n      }\n    }\n  };\n  visitWorkspace(graph);\n\n  return workspaceNodes;\n};\n\nexport const getAlternativeWorkspaceRoutes = (graph: WorkGraph, packageIds: Set<PackageId>): WorkspaceUsageRoutes => {\n  const usages = new Map();\n  const seen = new Set();\n\n  const visitDependency = (graphRoute: GraphRoute, node: WorkGraph) => {\n    const isSeen = seen.has(node);\n    seen.add(node);\n\n    const realId = fromAliasedId(node.id).id;\n    if (packageIds.has(realId) && graphRoute.length > 0 && !graphRoute[graphRoute.length - 1].isWorkspaceDep) {\n      let workspaceRoutes = usages.get(realId);\n      if (!workspaceRoutes) {\n        workspaceRoutes = new Set();\n        usages.set(realId, workspaceRoutes);\n      }\n      workspaceRoutes.add(graphRoute.slice(0));\n    }\n\n    if (!isSeen) {\n      if (node.workspaces) {\n        for (const [name, dep] of node.workspaces) {\n          graphRoute.push({ isWorkspaceDep: true, name });\n          visitDependency(graphRoute, dep);\n          graphRoute.pop();\n        }\n      }\n\n      if (node.dependencies) {\n        for (const [name, dep] of node.dependencies) {\n          graphRoute.push({ isWorkspaceDep: false, name });\n          visitDependency(graphRoute, dep);\n          graphRoute.pop();\n        }\n      }\n    }\n  };\n\n  visitDependency([], graph);\n\n  return usages;\n};\n", "import { getHoistingDecision, finalizeDependedDecisions, Hoistable, HoistingDecision } from './decision';\nimport { getChildren, getPriorities, getUsages, HoistingPriorities } from './priority';\nimport { getWorkspaceNodes, getAlternativeWorkspaceRoutes, WorkspaceUsageRoutes } from './workspace';\n\nexport type HoistingOptions = {\n  trace?: boolean;\n  dump?: boolean;\n  check?: CheckType;\n  explain?: boolean;\n  showChanges?: boolean;\n  preserveSymlinksSafe?: boolean;\n};\n\nexport type PackageId = string;\nexport type PackageName = string;\n\nexport type GraphRoute = Array<{ name: PackageName; isWorkspaceDep: boolean }>;\n\nexport enum PackageType {\n  PORTAL = 'PORTAL',\n}\n\nexport enum CheckType {\n  THOROUGH = 'THOROUGH',\n  FINAL = 'FINAL',\n}\n\nexport type Graph = {\n  id: string;\n  alias?: string;\n  dependencies?: Graph[];\n  workspaces?: Graph[];\n  peerNames?: string[];\n  packageType?: PackageType;\n  wall?: string[];\n  priority?: number;\n  reason?: string;\n  parent?: Graph;\n  workspace?: Graph;\n  bin?: Record<string, string>;\n\n  workspacePath?: string;\n  tarballUrl?: string;\n  buildScripts?: Record<string, string>;\n  optional?: boolean;\n};\n\nexport type WorkGraph = {\n  id: PackageId;\n  hoistingPriorities: HoistingPriorities;\n  dependencies?: Map<PackageName, WorkGraph>;\n  lookupUsages?: Map<PackageId, Set<PackageName>>;\n  lookupDependants?: Map<PackageName, Set<PackageId>>;\n  workspaces?: Map<PackageName, WorkGraph>;\n  peerNames?: Map<PackageName, GraphRoute | null>;\n  binEntries: Map<string, PackageId>;\n  ownBinEntries: Set<string>;\n  packageType?: PackageType;\n  queueIndex?: number;\n  wall?: Set<PackageName>;\n  originalNode: Graph;\n  originalParent?: WorkGraph;\n  newParent?: WorkGraph;\n  workspace?: WorkGraph;\n  priority?: number;\n  reason?: string;\n  lastDecisions: Map<PackageName, HoistingDecision>;\n};\n\nexport const getPackageName = (pkgId: PackageId): PackageName => {\n  const idx = pkgId.indexOf(`@`, 1);\n  return (idx < 0 ? pkgId : pkgId.substring(0, idx)) as PackageName;\n};\n\nconst getGraphPath = (graphRoute: GraphRoute, graph: WorkGraph) => {\n  const graphPath = [graph];\n  let node = graph;\n  for (const nextDep of graphRoute) {\n    if (nextDep.isWorkspaceDep) {\n      node = node.workspaces!.get(nextDep.name)!;\n    } else {\n      node = node.dependencies!.get(nextDep.name)!;\n    }\n    graphPath.push(node.workspace || node);\n  }\n  return graphPath;\n};\n\nconst cloneNode = (node: WorkGraph): WorkGraph => {\n  if (node.workspace) return node;\n\n  const clone: WorkGraph = {\n    id: node.id,\n    hoistingPriorities: node.hoistingPriorities,\n    lastDecisions: new Map(),\n    originalNode: node.originalNode,\n    binEntries: new Map(node.binEntries),\n    ownBinEntries: node.ownBinEntries,\n  };\n\n  if (node.packageType) {\n    clone.packageType = node.packageType;\n  }\n\n  if (node.peerNames) {\n    clone.peerNames = new Map(node.peerNames);\n  }\n\n  if (node.wall) {\n    clone.wall = node.wall;\n  }\n\n  if (node.workspaces) {\n    clone.workspaces = new Map(node.workspaces);\n  }\n\n  if (node.dependencies) {\n    clone.dependencies = new Map(node.dependencies);\n    const nodeName = getPackageName(node.id);\n    const selfNameDep = node.dependencies.get(nodeName);\n    if (selfNameDep === node) {\n      clone.dependencies.set(nodeName, clone);\n    }\n  }\n\n  if (node.priority) {\n    clone.priority = node.priority;\n  }\n\n  return clone;\n};\n\nconst getAliasedId = (pkg: Graph): PackageId => (!pkg.alias ? pkg.id : `${pkg.alias}@>${pkg.id}`);\n\nexport const fromAliasedId = (aliasedId: PackageId): { alias?: PackageName; id: PackageId } => {\n  const alias = getPackageName(aliasedId);\n  const idIndex = aliasedId.indexOf('@>', alias.length);\n  return idIndex < 0 ? { id: aliasedId } : { alias, id: aliasedId.substring(idIndex + 2) };\n};\n\nconst populateImplicitPeers = (graph: WorkGraph) => {\n  const seen = new Set();\n\n  const visitDependency = (graphPath: WorkGraph[]) => {\n    const node = graphPath[graphPath.length - 1];\n    const isSeen = seen.has(node);\n    seen.add(node);\n\n    if (node.peerNames && graphPath.length > 1) {\n      const parent = graphPath[graphPath.length - 2];\n      for (const [peerName, route] of node.peerNames) {\n        if (route === null && !parent.dependencies?.has(peerName) && !parent.peerNames?.has(peerName)) {\n          const route: GraphRoute = [\n            {\n              name: getPackageName(node.id),\n              isWorkspaceDep: node.workspace === node,\n            },\n          ];\n          for (let idx = graphPath.length - 2; idx >= 0; idx--) {\n            const parent = graphPath[idx];\n            if (parent.dependencies?.has(peerName)) {\n              for (let j = idx + 1; j < graphPath.length - 1; j++) {\n                const peerNode = graphPath[j];\n                if (!peerNode.peerNames) {\n                  peerNode.peerNames = new Map();\n                }\n                if (!peerNode.peerNames.has(peerName)) {\n                  peerNode.peerNames.set(peerName, route);\n                }\n              }\n              break;\n            } else {\n              route.unshift({ name: getPackageName(parent.id), isWorkspaceDep: parent.workspace === parent });\n            }\n          }\n        }\n      }\n    }\n\n    if (!isSeen) {\n      if (node.workspaces) {\n        for (const dep of node.workspaces.values()) {\n          graphPath.push(dep);\n          visitDependency(graphPath);\n          graphPath.pop();\n        }\n      }\n\n      if (node.dependencies) {\n        for (const dep of node.dependencies.values()) {\n          graphPath.push(dep);\n          visitDependency(graphPath);\n          graphPath.pop();\n        }\n      }\n    }\n  };\n\n  visitDependency([graph]);\n};\n\nexport const toWorkGraph = (rootPkg: Graph): WorkGraph => {\n  const seen = new Map<Graph, WorkGraph>();\n  const workspaceNodes = new Map<PackageId, WorkGraph>();\n  const workspaceRefs = new Map<WorkGraph, WorkGraph>();\n  const idMap = new Map<string, { node: Graph; parent?: Graph }>();\n\n  const createWorkspaceNodes = (pkg: Graph) => {\n    const workspace: WorkGraph = {\n      id: pkg.id,\n      hoistingPriorities: new Map(),\n      lastDecisions: new Map(),\n      originalNode: pkg,\n      binEntries: new Map(),\n      ownBinEntries: new Set(),\n    };\n    workspaceNodes.set(workspace.id, workspace);\n    if (pkg.workspaces) {\n      for (const dep of pkg.workspaces) {\n        createWorkspaceNodes(dep);\n      }\n    }\n  };\n\n  createWorkspaceNodes(rootPkg);\n\n  const convertNode = (pkg: Graph, isWorkspace: boolean, parent?: Graph): WorkGraph => {\n    const aliasedId = getAliasedId(pkg);\n    if (!isWorkspace) {\n      const seenIdInstance = idMap.get(aliasedId);\n      if (typeof seenIdInstance !== 'undefined' && seenIdInstance.node !== pkg) {\n        throw new Error(\n          `Package ${pkg.id}${\n            pkg.alias ? ' with alias ' + pkg.alias : ''\n          } has multiple instances in the graph, which is disallowed:\\n1: ${JSON.stringify(\n            seenIdInstance.node,\n          )}, parent: ${seenIdInstance.parent?.id}\\n2: ${JSON.stringify(pkg)}, parent: ${parent?.id}`,\n        );\n      }\n      idMap.set(aliasedId, { node: pkg, parent });\n    }\n\n    const seenNode = seen.get(pkg);\n    const newNode: WorkGraph = isWorkspace\n      ? workspaceNodes.get(pkg.id)!\n      : seenNode || {\n          id: aliasedId,\n          hoistingPriorities: new Map(),\n          lastDecisions: new Map(),\n          originalNode: pkg,\n          binEntries: new Map(),\n          ownBinEntries: new Set(),\n        };\n    seen.set(pkg, newNode);\n    if (pkg === rootPkg) {\n      newNode.workspace = newNode;\n    }\n\n    if (!seenNode) {\n      if (pkg.packageType) {\n        newNode.packageType = pkg.packageType;\n      }\n\n      if (pkg.peerNames) {\n        newNode.peerNames = new Map();\n        for (const peerName of pkg.peerNames) {\n          newNode.peerNames.set(peerName, null);\n        }\n      }\n\n      if (pkg.wall) {\n        newNode.wall = new Set(pkg.wall);\n      }\n\n      if (pkg.priority) {\n        newNode.priority = pkg.priority;\n      }\n\n      if (pkg.bin) {\n        for (const scriptName of Object.keys(pkg.bin)) {\n          newNode.binEntries.set(scriptName, pkg.id);\n          newNode.ownBinEntries.add(scriptName);\n        }\n      }\n\n      if (pkg.workspaces && pkg.workspaces.length > 0) {\n        newNode.workspaces = new Map();\n\n        for (const dep of pkg.workspaces) {\n          const name = dep.alias || getPackageName(dep.id);\n          const depNode = convertNode(dep, true, pkg);\n          depNode.workspace = depNode;\n          newNode.workspaces.set(name, depNode);\n        }\n      }\n\n      if (pkg.dependencies && pkg.dependencies.length > 0) {\n        newNode.dependencies = new Map();\n\n        for (const dep of pkg.dependencies || []) {\n          const name = dep.alias || getPackageName(dep.id);\n          const depNode: WorkGraph = convertNode(dep, false, pkg);\n          if (dep.bin) {\n            for (const scriptName of Object.keys(dep.bin)) {\n              newNode.binEntries.set(scriptName, dep.id);\n            }\n          }\n\n          const workspace = workspaceNodes.get(dep.id);\n          if (workspace) {\n            let workspaceRef = workspaceRefs.get(depNode);\n            if (!workspaceRef) {\n              workspaceRef = {\n                id: depNode.id,\n                hoistingPriorities: new Map(),\n                lastDecisions: new Map(),\n                workspace,\n                originalNode: depNode.originalNode,\n                binEntries: new Map(),\n                ownBinEntries: new Set(),\n              };\n              workspaceRefs.set(depNode, workspaceRef);\n            }\n            newNode.dependencies.set(name, workspaceRef);\n          } else {\n            newNode.dependencies.set(name, depNode);\n          }\n        }\n      }\n    }\n\n    return newNode;\n  };\n\n  const graph = convertNode(rootPkg, true);\n  graph.workspace = graph;\n\n  const seenNodes = new Set();\n  const usages = getUsages(graph);\n  const fillPriorities = (node: WorkGraph) => {\n    if (seenNodes.has(node)) return;\n    seenNodes.add(node);\n\n    const children = getChildren(node);\n    node.hoistingPriorities = getPriorities(usages, children);\n\n    if (node.workspaces) {\n      for (const dep of node.workspaces.values()) {\n        fillPriorities(dep);\n      }\n    }\n\n    if (node.dependencies) {\n      for (const dep of node.dependencies.values()) {\n        fillPriorities(dep);\n      }\n    }\n  };\n\n  fillPriorities(graph);\n\n  return graph;\n};\n\nconst fromWorkGraph = (graph: WorkGraph): Graph => {\n  const nodeMap = new Map<WorkGraph, Graph>();\n\n  const cloneNode = (node: WorkGraph, parent: Graph | null): Graph => {\n    let pkg = nodeMap.get(node);\n    if (pkg) return pkg;\n\n    const { alias, id } = fromAliasedId(node.id);\n    pkg = { id };\n    if (alias) {\n      pkg.alias = alias;\n    }\n    nodeMap.set(node, pkg);\n\n    if (node.packageType) {\n      pkg.packageType = node.packageType;\n    }\n\n    if (node.peerNames) {\n      for (const [peerName, route] of node.peerNames) {\n        if (route === null) {\n          if (!pkg.peerNames) {\n            pkg.peerNames = [];\n          }\n          pkg.peerNames.push(peerName);\n        }\n      }\n    }\n\n    if (node.reason) {\n      pkg.reason = node.reason;\n    }\n\n    if (node.wall) {\n      pkg.wall = Array.from(node.wall).sort();\n    }\n\n    if (node.priority) {\n      pkg.priority = node.priority;\n    }\n\n    if (node.workspaces) {\n      pkg.workspaces = [];\n    }\n\n    if (node.dependencies) {\n      pkg.dependencies = [];\n    }\n\n    if (parent) {\n      pkg.parent = parent;\n    }\n\n    if (!node.workspace || node.workspace === node) {\n      const originalNode = node.originalNode;\n      if (originalNode.bin) {\n        pkg.bin = originalNode.bin;\n      }\n\n      if (originalNode.buildScripts) {\n        pkg.buildScripts = originalNode.buildScripts;\n      }\n\n      if (originalNode.workspacePath) {\n        pkg.workspacePath = originalNode.workspacePath;\n      }\n\n      if (originalNode.tarballUrl) {\n        pkg.tarballUrl = originalNode.tarballUrl;\n      }\n\n      if (originalNode.optional) {\n        pkg.optional = originalNode.optional;\n      }\n    }\n\n    if (node.workspaces) {\n      for (const dep of node.workspaces.values()) {\n        cloneNode(dep, pkg);\n      }\n    }\n\n    if (node.dependencies) {\n      for (const dep of node.dependencies.values()) {\n        if (!dep.newParent || dep.newParent === node) {\n          cloneNode(dep, pkg);\n        }\n      }\n    }\n\n    return pkg;\n  };\n\n  const rootPkg: Graph = cloneNode(graph, null);\n\n  const getClonedNode = (node: WorkGraph): Graph => {\n    const clonedNode = nodeMap.get(node);\n    if (!clonedNode) {\n      throw new Error(`Assertion: expected to have cloned node: ${node.id}`);\n    }\n\n    return clonedNode;\n  };\n\n  const visitDependency = (graphPath: WorkGraph[], pkg: Graph) => {\n    let node = graphPath[graphPath.length - 1];\n    if (graphPath.indexOf(node) !== graphPath.length - 1) return;\n\n    if (node.workspaces) {\n      const sortedEntries = Array.from(node.workspaces.entries()).sort((x1, x2) =>\n        x1[0] === x2[0] ? 0 : x1[0] < x2[0] ? -1 : 1,\n      );\n\n      pkg.workspaces = [];\n\n      for (const [, dep] of sortedEntries) {\n        const depPkg = getClonedNode(dep);\n        pkg.workspaces.push(depPkg);\n\n        graphPath.push(dep);\n        visitDependency(graphPath, depPkg);\n        graphPath.pop();\n      }\n    }\n\n    if (node.workspace) {\n      pkg.workspace = getClonedNode(node.workspace);\n    }\n\n    if (node.dependencies) {\n      const sortedEntries = Array.from(node.dependencies.entries()).sort((x1, x2) =>\n        x1[0] === x2[0] ? 0 : x1[0] < x2[0] ? -1 : 1,\n      );\n\n      pkg.dependencies = [];\n      for (const [depName, dep] of sortedEntries) {\n        if (!dep.newParent || dep.newParent === node) {\n          const depPkg = getClonedNode(dep);\n          pkg.dependencies.push(depPkg);\n\n          graphPath.push(dep);\n          visitDependency(graphPath, depPkg);\n          graphPath.pop();\n        } else if (dep.originalParent === node && dep.newParent !== node) {\n          let depNode = dep,\n            parent = node;\n          do {\n            parent = depNode.newParent!;\n            depNode = parent.dependencies!.get(depName)!;\n          } while (depNode.newParent && depNode.newParent !== parent);\n\n          const depPkg = getClonedNode(depNode);\n          pkg.dependencies.push(depPkg);\n        }\n      }\n    }\n  };\n\n  visitDependency([graph], rootPkg);\n\n  return rootPkg;\n};\n\ntype QueueElement = { graphPath: WorkGraph[]; depName: PackageName };\ntype HoistingQueue = Array<QueueElement[]>;\n\nconst hoistDependencies = (\n  graphPath: WorkGraph[],\n  queueIndex: number,\n  depNames: Set<PackageName>,\n  options: HoistingOptions,\n  hoistingQueue: HoistingQueue,\n  lastWorkspaceIndex: number,\n  workspaceUsageRoutes: WorkspaceUsageRoutes,\n): boolean => {\n  let wasGraphChanged = false;\n  const parentPkg = graphPath[graphPath.length - 1];\n\n  if (options.trace) {\n    console.log(queueIndex === 0 ? 'visit' : 'revisit', graphPath.map((x) => x.id).join('/'), depNames);\n  }\n\n  const preliminaryDecisionMap = new Map<PackageName, HoistingDecision>();\n  for (const depName of depNames) {\n    let decision = getHoistingDecision(graphPath, depName, queueIndex);\n    if (\n      options.preserveSymlinksSafe &&\n      decision.isHoistable !== Hoistable.LATER &&\n      decision.newParentIndex < lastWorkspaceIndex\n    ) {\n      const workspaceId = fromAliasedId(graphPath[lastWorkspaceIndex].id).id;\n      const alternativeGraphRoutes = workspaceUsageRoutes.get(workspaceId);\n      if (alternativeGraphRoutes) {\n        for (const workspaceGraphRoute of alternativeGraphRoutes) {\n          const graphPathToWorkspace = getGraphPath(workspaceGraphRoute, graphPath[0]);\n          const usageGraphPath = graphPathToWorkspace.concat(graphPath.slice(lastWorkspaceIndex + 1));\n          const usageDecision = getHoistingDecision(usageGraphPath, depName, queueIndex);\n          if (options.trace) {\n            console.log(\n              'alternative usage path:',\n              usageGraphPath.map((x) => x.id).join('/'),\n              depName,\n              'decision:',\n              usageDecision,\n            );\n          }\n          if (usageDecision.isHoistable === Hoistable.LATER) {\n            decision = usageDecision;\n            if (options.trace) {\n              console.log('updated decision:', decision);\n            }\n            break;\n          } else {\n            for (let idx = usageDecision.newParentIndex; idx < usageGraphPath.length; idx++) {\n              let originalIndex;\n              const node = usageGraphPath[idx];\n              for (originalIndex = graphPath.length - 1; originalIndex >= 0; originalIndex--) {\n                if (graphPath[originalIndex].id === node.id) {\n                  break;\n                }\n              }\n              if (originalIndex >= 0) {\n                if (originalIndex > decision.newParentIndex) {\n                  decision.newParentIndex = originalIndex;\n                  decision.reason = `dependency was not hoisted due to ${usageDecision.reason!} at alternative usage route: ${printGraphPath(\n                    usageGraphPath,\n                  )}`;\n                  if (options.trace) {\n                    console.log('updated decision:', decision);\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    preliminaryDecisionMap.set(depName, decision);\n  }\n\n  const finalDecisions = finalizeDependedDecisions(graphPath, preliminaryDecisionMap, options);\n\n  const hoistDependency = (dep: WorkGraph, depName: PackageName, newParentIndex: number) => {\n    delete dep.queueIndex;\n    const rootPkg = graphPath[newParentIndex];\n    if (rootPkg.workspace && rootPkg.workspace !== rootPkg) {\n      throw new Error(`Assertion: trying to hoist into workspace reference: ${rootPkg.id}`);\n    }\n    for (let idx = newParentIndex; idx < graphPath.length - 1; idx++) {\n      const pkg = graphPath[idx];\n      const rootPkgDep = pkg.dependencies?.get(depName);\n      if (!rootPkgDep) {\n        if (!pkg.dependencies) {\n          pkg.dependencies = new Map();\n        }\n        pkg.dependencies.set(depName, dep);\n      }\n\n      if (!pkg.lookupUsages) {\n        pkg.lookupUsages = new Map();\n      }\n\n      let lookupNameList = pkg.lookupUsages.get(parentPkg.id);\n      if (!lookupNameList) {\n        lookupNameList = new Set();\n        pkg.lookupUsages.set(parentPkg.id, lookupNameList);\n      }\n      lookupNameList.add(depName);\n\n      if (!pkg.lookupDependants) {\n        pkg.lookupDependants = new Map();\n      }\n\n      let dependantList = pkg.lookupDependants.get(depName);\n      if (!dependantList) {\n        dependantList = new Set();\n        pkg.lookupDependants.set(depName, dependantList);\n      }\n      dependantList.add(parentPkg.id);\n    }\n    dep.newParent = rootPkg;\n\n    for (let idx = newParentIndex + 1; idx < graphPath.length; idx++) {\n      const pkg = graphPath[idx];\n      if (pkg.lookupUsages) {\n        const depLookupNames = pkg.lookupUsages.get(dep.id);\n        if (depLookupNames) {\n          for (const name of depLookupNames) {\n            const dependantList = pkg.lookupDependants!.get(name)!;\n            dependantList.delete(dep.id);\n            if (dependantList.size === 0) {\n              pkg.lookupDependants!.delete(name);\n              const pkgDep = pkg.dependencies!.get(name)!;\n              // Delete \"lookup\" dependency, because of empty set of dependants\n              if (pkgDep!.newParent && pkgDep!.newParent !== pkg) {\n                if (options.trace) {\n                  console.log(\n                    `clearing previous lookup dependency by ${dep.id} on ${pkgDep.id} in`,\n                    graphPath.slice(0, idx + 1).map((x) => x.id),\n                  );\n                }\n                pkg.dependencies!.delete(name);\n              }\n            }\n          }\n        }\n        pkg.lookupUsages.delete(dep.id);\n      }\n    }\n  };\n\n  if (finalDecisions.circularPackageNames.size > 0) {\n    for (const depName of finalDecisions.circularPackageNames) {\n      const dep = parentPkg.dependencies!.get(depName)!;\n      const decision = finalDecisions.decisionMap.get(depName)!;\n      if (decision.isHoistable === Hoistable.DEPENDS) {\n        if (dep.newParent !== graphPath[decision.newParentIndex]) {\n          if (options.showChanges) {\n            console.log(`unexpected decision to hoist ${dep.id} at ${printGraphPath(graphPath)}`, decision);\n          }\n          hoistDependency(dep, depName, decision.newParentIndex);\n          wasGraphChanged = true;\n        }\n      }\n    }\n\n    if (options.check === CheckType.THOROUGH) {\n      const log = checkContracts(graphPath[0]);\n      if (log) {\n        console.log(\n          `Contracts violated after hoisting ${Array.from(finalDecisions.circularPackageNames)} from ${printGraphPath(\n            graphPath,\n          )}\\n${log}${print(graphPath[0])}`,\n        );\n      }\n    }\n  }\n\n  for (const depName of finalDecisions.decisionMap.keys()) {\n    const dep = parentPkg.dependencies!.get(depName)!;\n    const decision = finalDecisions.decisionMap.get(depName)!;\n    if (decision.isHoistable === Hoistable.YES && decision.newParentIndex !== graphPath.length - 1) {\n      if (dep.newParent !== graphPath[decision.newParentIndex]) {\n        if (options.showChanges) {\n          console.log(\n            `unexpected decision to hoist ${dep.id} at ${printGraphPath(graphPath)}${\n              parentPkg.newParent ? ' previously hoisted' : ''\n            }`,\n            decision,\n            'previous:',\n            parentPkg.lastDecisions.get(depName),\n          );\n        }\n        hoistDependency(dep, depName, decision.newParentIndex);\n        wasGraphChanged = true;\n\n        if (options.check === CheckType.THOROUGH) {\n          const log = checkContracts(graphPath[0]);\n          if (log) {\n            throw new Error(\n              `Contracts violated after hoisting ${depName} from ${printGraphPath(graphPath)}\\n${log}${print(\n                graphPath[0],\n              )}`,\n            );\n          }\n        }\n      }\n    } else if (decision.isHoistable === Hoistable.LATER) {\n      if (options.trace) {\n        console.log(\n          'queue',\n          graphPath\n            .map((x) => x.id)\n            .concat([dep.id])\n            .join('/'),\n          'to index:',\n          decision.queueIndex,\n          'current index:',\n          queueIndex,\n        );\n      }\n      dep.queueIndex = decision.queueIndex;\n\n      hoistingQueue![decision.queueIndex].push({\n        graphPath: graphPath.slice(0),\n        depName,\n      });\n    } else {\n      if (options.explain && decision.reason) {\n        dep.reason = decision.reason;\n      }\n      delete dep.queueIndex;\n    }\n    parentPkg.lastDecisions.set(depName, decision);\n  }\n\n  return wasGraphChanged;\n};\n\nconst hoistGraph = (graph: WorkGraph, options: HoistingOptions): boolean => {\n  let wasGraphChanged = false;\n\n  if (options.check) {\n    const log = checkContracts(graph);\n    if (log) {\n      throw new Error(`Contracts violated on initial graph:\\n${log}`);\n    }\n  }\n\n  const usages = getUsages(graph);\n  const children = getChildren(graph);\n  const priorities = getPriorities(usages, children);\n\n  let maxQueueIndex = 0;\n  for (const priorityIds of priorities.values()) {\n    maxQueueIndex = Math.max(maxQueueIndex, priorityIds.length);\n  }\n  const hoistingQueue: HoistingQueue = [];\n  for (let idx = 0; idx < maxQueueIndex; idx++) {\n    hoistingQueue.push([]);\n  }\n  let queueIndex = 0;\n\n  const workspaceNodes = getWorkspaceNodes(graph);\n  let workspaceUsageRoutes: WorkspaceUsageRoutes = new Map();\n  if (options.preserveSymlinksSafe) {\n    workspaceUsageRoutes = getAlternativeWorkspaceRoutes(graph, new Set(workspaceNodes.keys()));\n    if (options.trace && workspaceUsageRoutes.size > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      console.log('alternative workspace usage routes', require('util').inspect(workspaceUsageRoutes, false, null));\n    }\n  }\n\n  const visitParent = (graphPath: WorkGraph[], lastWorkspaceIndex: number) => {\n    const node = graphPath[graphPath.length - 1];\n\n    if (node.dependencies) {\n      for (const [depName, dep] of node.dependencies) {\n        if (!dep.originalParent && dep !== graph) {\n          const newDep = cloneNode(dep);\n          newDep.originalParent = node;\n          node.dependencies!.set(depName, newDep);\n        }\n      }\n    }\n\n    if (node.workspaces) {\n      for (const workspaceDep of node.workspaces.values()) {\n        workspaceDep.originalParent = node;\n      }\n    }\n\n    if (graphPath.length > 1 && node.dependencies) {\n      const dependencies = new Set<PackageName>();\n      for (const [depName, dep] of node.dependencies) {\n        if (!dep.newParent || dep.newParent === node) {\n          dependencies.add(depName);\n        }\n      }\n\n      if (dependencies.size > 0) {\n        if (\n          hoistDependencies(\n            graphPath,\n            queueIndex,\n            dependencies,\n            options,\n            hoistingQueue,\n            lastWorkspaceIndex,\n            workspaceUsageRoutes,\n          )\n        ) {\n          wasGraphChanged = true;\n        }\n      }\n    }\n\n    if (graphPath.indexOf(node) === graphPath.length - 1) {\n      if (node.workspaces) {\n        for (const depWorkspace of node.workspaces.values()) {\n          const depPriorities = getPriorities(usages, getChildren(depWorkspace));\n          if (depPriorities.size > 0) {\n            graphPath.push(depWorkspace);\n            visitParent(graphPath, lastWorkspaceIndex + 1);\n            graphPath.pop();\n          }\n        }\n      }\n\n      if (node.dependencies) {\n        for (const [, dep] of node.dependencies) {\n          if (dep.id !== node.id && !dep.workspace && (!dep.newParent || dep.newParent === node)) {\n            const depPriorities = dep.hoistingPriorities;\n            if (depPriorities.size > 0) {\n              graphPath.push(dep);\n              visitParent(graphPath, lastWorkspaceIndex);\n              graphPath.pop();\n            }\n          }\n        }\n      }\n    }\n  };\n\n  visitParent([graph], 0);\n\n  for (queueIndex = 1; queueIndex < maxQueueIndex; queueIndex++) {\n    while (hoistingQueue[queueIndex].length > 0) {\n      const queueElement = hoistingQueue[queueIndex].shift()!;\n      const graphPath: WorkGraph[] = [];\n      let node: WorkGraph | undefined = queueElement.graphPath[queueElement.graphPath.length - 1];\n      do {\n        graphPath.unshift(node);\n        node = node.newParent || node.originalParent;\n      } while (node);\n\n      let lastWorkspaceIndex = 0;\n      for (let idx = graphPath.length - 1; idx >= 0; idx--) {\n        const node = graphPath[idx];\n        const realId = fromAliasedId(node.id).id;\n        if (workspaceNodes.has(realId)) {\n          lastWorkspaceIndex = idx;\n          break;\n        }\n      }\n\n      if (\n        hoistDependencies(\n          graphPath,\n          queueIndex,\n          new Set([queueElement.depName]),\n          options,\n          hoistingQueue,\n          lastWorkspaceIndex,\n          workspaceUsageRoutes,\n        )\n      ) {\n        wasGraphChanged = true;\n      }\n    }\n  }\n\n  if (options.check === CheckType.FINAL) {\n    const log = checkContracts(graph);\n    if (log) {\n      throw new Error(`Contracts violated after hoisting finished:\\n${log}`);\n    }\n  }\n\n  return wasGraphChanged;\n};\n\nconst cloneWorkGraph = (graph: WorkGraph): WorkGraph => {\n  const clonedNodes = new Map<WorkGraph, WorkGraph>();\n\n  const cloneDependency = (node: WorkGraph) => {\n    if (node.workspace) return node;\n\n    let clonedNode = clonedNodes.get(node);\n\n    if (!clonedNode) {\n      clonedNode = Object.assign({}, node);\n\n      delete clonedNode.queueIndex;\n      clonedNodes.set(node, clonedNode);\n\n      if (node.dependencies) {\n        for (const dep of node.dependencies.values()) {\n          cloneDependency(dep);\n        }\n      }\n    }\n\n    return clonedNode;\n  };\n\n  const getClonedNode = (originalNode: WorkGraph): WorkGraph => {\n    const clonedNode = clonedNodes.get(originalNode);\n    if (!clonedNode) {\n      throw new Error('Clone error');\n    }\n    return clonedNode;\n  };\n\n  const clonedGraph = cloneDependency(graph);\n\n  for (const node of clonedNodes.values()) {\n    if (node.originalParent) {\n      node.originalParent = cloneDependency(node.originalParent);\n    }\n\n    if (node.newParent) {\n      node.newParent = cloneDependency(node.newParent);\n    }\n\n    if (node.dependencies) {\n      const newDependencies = new Map();\n      for (const [depName, dep] of node.dependencies) {\n        newDependencies.set(depName, getClonedNode(dep));\n      }\n      node.dependencies = newDependencies;\n    }\n\n    if (node.workspaces) {\n      const newWorkspaces = new Map();\n      for (const [depName, dep] of node.workspaces) {\n        newWorkspaces.set(depName, getClonedNode(dep));\n      }\n      node.workspaces = newWorkspaces;\n    }\n\n    if (node.lookupUsages) {\n      node.lookupUsages = new Map(node.lookupUsages);\n    }\n\n    if (node.lookupDependants) {\n      const newLookupDependants = new Map();\n      for (const [depName, usedBySet] of node.lookupDependants) {\n        newLookupDependants.set(depName, new Set(usedBySet));\n      }\n      node.lookupDependants = newLookupDependants;\n    }\n  }\n\n  return clonedGraph;\n};\n\nexport const hoist = (pkg: Graph, opts?: HoistingOptions): Graph => {\n  let graph = toWorkGraph(pkg);\n  const options = opts || { trace: false };\n\n  populateImplicitPeers(graph);\n\n  let wasGraphChanged = true;\n  do {\n    wasGraphChanged = hoistGraph(graph, options);\n    if (wasGraphChanged) graph = cloneWorkGraph(graph);\n  } while (wasGraphChanged);\n\n  if (options.check) {\n    if (options.trace) {\n      console.log('second pass');\n    }\n\n    const secondGraph = cloneWorkGraph(graph);\n    let wasGraphChanged = false;\n    try {\n      wasGraphChanged = hoistGraph(secondGraph, { ...options, showChanges: true });\n    } catch (e: any) {\n      e.message = `While checking for terminal result: ${e.message}`;\n      throw e;\n    }\n    if (wasGraphChanged) {\n      throw new Error(`Hoister produced non-terminal result`);\n    }\n  }\n\n  if (options.trace || options.dump) {\n    console.log(`final hoisted graph:\\n${print(graph)}`);\n  }\n\n  return fromWorkGraph(graph);\n};\n\nconst getOriginalGrapPath = (node: WorkGraph): WorkGraph[] => {\n  const graphPath: WorkGraph[] = [];\n\n  let pkg: WorkGraph | undefined = node;\n  do {\n    if (pkg) {\n      graphPath.unshift(pkg);\n      pkg = pkg.originalParent;\n    }\n  } while (pkg);\n\n  return graphPath;\n};\n\nconst getLatestGrapPath = (node: WorkGraph): WorkGraph[] => {\n  const graphPath: WorkGraph[] = [];\n\n  let pkg: WorkGraph | undefined = node;\n  do {\n    if (pkg) {\n      graphPath.unshift(pkg);\n      pkg = pkg.newParent || pkg.originalParent;\n    }\n  } while (pkg);\n\n  return graphPath;\n};\n\nexport const printGraphPath = (graphPath: WorkGraph[]): string => graphPath.map((x) => x.id).join('/');\n\nconst checkContracts = (graph: WorkGraph): string => {\n  const seen = new Set();\n  const checkParent = (graphPath: WorkGraph[]): string => {\n    const node = graphPath[graphPath.length - 1];\n    const isSeen = seen.has(node);\n    seen.add(node);\n\n    let log = '';\n\n    const originalDependencies = node?.originalParent?.dependencies?.get(getPackageName(node.id))?.dependencies;\n    if (originalDependencies) {\n      for (const [depName, originalDep] of originalDependencies) {\n        let actualDep;\n        for (let idx = graphPath.length - 1; idx >= 0; idx--) {\n          actualDep = graphPath[idx]?.dependencies?.get(depName);\n          if (actualDep) {\n            break;\n          }\n        }\n\n        if (actualDep?.id !== originalDep.id) {\n          log += `Expected ${originalDep.id} for ${printGraphPath(graphPath.slice(0, -1))}, but found: ${printGraphPath(\n            getLatestGrapPath(actualDep),\n          )}`;\n          if (actualDep?.newParent) {\n            log += ` previously hoisted from ${printGraphPath(getOriginalGrapPath(actualDep))}`;\n          }\n          log += `\\n`;\n        }\n      }\n    }\n\n    if (node.peerNames) {\n      const originalGraphPath = getOriginalGrapPath(node);\n      for (const peerName of node.peerNames.keys()) {\n        let originalPeerDep;\n        for (let idx = originalGraphPath.length - 2; idx >= 0; idx--) {\n          const nodeDep = originalGraphPath[idx].dependencies?.get(peerName);\n          if (nodeDep?.originalParent == originalGraphPath[idx]) {\n            originalPeerDep = nodeDep;\n            break;\n          }\n        }\n\n        if (originalPeerDep) {\n          let actualPeerDep;\n          for (let idx = graphPath.length - 1; idx >= 0; idx--) {\n            const nodeDep = graphPath[idx].dependencies?.get(peerName);\n            if (nodeDep && (nodeDep.newParent || nodeDep.originalParent) == graphPath[idx]) {\n              actualPeerDep = nodeDep;\n              break;\n            }\n          }\n\n          let parentPeerDep;\n          for (let idx = graphPath.length - 2; idx >= 0; idx--) {\n            const nodeDep = graphPath[idx].dependencies?.get(peerName);\n            if (nodeDep && (nodeDep.newParent || nodeDep.originalParent) == graphPath[idx]) {\n              parentPeerDep = nodeDep;\n              break;\n            }\n          }\n\n          if (actualPeerDep.id !== originalPeerDep.id) {\n            // log += `Expected peer dependency ${originalPeerDep.id} for ${printGraphPath(graphPath)}, but found: ${actualPeerDep?.id || 'none'\n            //   } at ${printGraphPath(getLatestGrapPath(actualPeerDep))}`;\n            // if (actualPeerDep?.newParent) {\n            //   log += ` previously hoisted from ${printGraphPath(getOriginalGrapPath(actualPeerDep))}`;\n            // }\n            // log += `\\n`;\n          } else if (actualPeerDep !== parentPeerDep) {\n            log += `Expected peer dependency ${printGraphPath(getLatestGrapPath(actualPeerDep))}`;\n            if (actualPeerDep?.newParent) {\n              log += ` previously hoisted from ${printGraphPath(getOriginalGrapPath(actualPeerDep))}`;\n            }\n            log += ` for ${printGraphPath(\n              graphPath,\n            )} to be shared with parent, but parent uses peer dependency from ${printGraphPath(\n              getLatestGrapPath(parentPeerDep),\n            )} instead\\n`;\n          }\n        }\n      }\n    }\n\n    if (!isSeen) {\n      if (node.workspaces) {\n        for (const dep of node.workspaces.values()) {\n          graphPath.push(dep);\n          log += checkParent(graphPath);\n          graphPath.pop();\n        }\n      }\n\n      if (node.dependencies) {\n        for (const dep of node.dependencies.values()) {\n          if ((dep.newParent || dep.originalParent) === node) {\n            graphPath.push(dep);\n            log += checkParent(graphPath);\n            graphPath.pop();\n          }\n        }\n      }\n    }\n\n    return log;\n  };\n\n  return checkParent([graph]);\n};\n\nconst print = (graph: WorkGraph): string => {\n  const printDependency = (\n    graphPath: WorkGraph[],\n    { prefix, depPrefix }: { prefix: string; depPrefix: string },\n  ): string => {\n    const node = graphPath[graphPath.length - 1];\n    let str = depPrefix;\n    if (node.workspace === node) {\n      str += 'workspace:';\n    } else if (node.packageType === PackageType.PORTAL) {\n      str += 'portal:';\n    }\n\n    str += node.id;\n    if (node.wall) {\n      str += '|';\n      if (node.wall.size > 0) {\n        str += Array.from(node.wall);\n      }\n    }\n    if (node.queueIndex) {\n      str += ` queue: ${node.queueIndex}`;\n    }\n    if (node.reason) {\n      str += ` - ${node.reason}`;\n    }\n    str += '\\n';\n\n    if (graphPath.indexOf(node) !== graphPath.length - 1) {\n      return str;\n    }\n\n    const deps: WorkGraph[] = [];\n    if (node.workspaces) {\n      for (const dep of node.workspaces.values()) {\n        deps.push(dep);\n      }\n    }\n\n    if (node.dependencies) {\n      for (const dep of node.dependencies.values()) {\n        if (!dep.newParent || dep.newParent === node) {\n          deps.push(dep);\n        }\n      }\n    }\n    deps.sort((d1, d2) => (d2.id < d1.id ? 1 : -1));\n\n    for (let idx = 0; idx < deps.length; idx++) {\n      const dep = deps[idx];\n      graphPath.push(dep);\n      const hasMoreDependencies = idx < deps.length - 1;\n      str += printDependency(graphPath, {\n        depPrefix: prefix + (hasMoreDependencies ? `\u251C\u2500` : `\u2514\u2500`),\n        prefix: prefix + (hasMoreDependencies ? `\u2502 ` : `  `),\n      });\n      graphPath.pop();\n    }\n\n    return str;\n  };\n\n  return printDependency([graph], { prefix: '  ', depPrefix: '' }).trim();\n};\n", "import path from 'path';\nimport crypto from 'crypto';\n\nimport { Graph } from '../hoister';\nimport { parseSpecifier } from '../resolver';\nimport { DOT_BIN, NODE_MODULES, BUILD_SCRIPTS } from '../constants';\nimport { RESOLVE_STATE_FILE } from '../resolver/resolver';\n\nexport type InstallEvent =\n  | {\n      type: InstallEventType.INSTALL;\n      id: string;\n      targetPath: string;\n      skipUnpack?: boolean;\n\n      tarballUrl: string;\n      binPath?: string;\n      bin?: Record<string, string>;\n    }\n  | {\n      type: InstallEventType.BUILD;\n      id: string;\n      targetPath: string;\n      optional?: boolean;\n      isWorkspace?: boolean;\n\n      buildScripts: Map<string, string>;\n      waitPaths: string[];\n    }\n  | {\n      type: InstallEventType.CLONE;\n      id: string;\n      targetPath: string;\n      skipUnpack?: boolean;\n\n      sourcePath: string;\n      binPath?: string;\n      bin?: Record<string, string>;\n    }\n  | {\n      type: InstallEventType.LINK;\n      id: string;\n      targetPath: string;\n\n      sourcePath: string;\n    }\n  | {\n      type: InstallEventType.READDIR;\n      targetPath: string;\n    }\n  | {\n      type: InstallEventType.DELETE;\n      targetPath: string;\n      cleanOnly?: boolean;\n    };\n\nexport enum InstallLink {\n  DIRECTORY = 'directory',\n  SYMLINK = 'symlink',\n}\nexport type InstallState = {\n  id?: string;\n  buildHash?: string;\n  buildFail?: string;\n  isLink?: boolean;\n  nodes?: Map<string, InstallState>;\n};\n\ntype WorkInstallState = InstallState & {\n  _cleanStatus?: CleanStatus;\n  _pathKind?: PathKind;\n};\n\nexport enum DirEntryType {\n  FILE = 'file',\n  DIRECTORY = 'directory',\n  SYMLINK = 'symlink',\n}\nexport type DirEntry = { name: string; type: DirEntryType };\nexport enum InstallEventType {\n  DELETE = 'delete',\n  READDIR = 'readdir',\n  INSTALL = 'install',\n  BUILD = 'build',\n  CLONE = 'clone',\n  LINK = 'link',\n}\n\nenum CleanStatus {\n  CLEAN = 'clean',\n  MISSING = 'missing',\n}\nenum PathKind {\n  NODE_MODULES = 'node_modules',\n  DOT_BIN = 'dot_bin',\n  BIN_LINK = 'bin_link',\n  SCOPE = 'scope',\n  PACKAGE = 'package',\n}\n\nconst parseName = (name: string): { scope: string | null; packageName: string } => {\n  const idx = name.indexOf('/');\n  return idx < 0\n    ? { scope: null, packageName: name }\n    : { scope: name.substring(0, idx), packageName: name.substring(idx + 1) };\n};\n\nconst getTransitiveDependencies = (workNode: Graph): Graph[] => {\n  const dependencies: Graph[] = [];\n  const seenNodes = new Set<Graph>();\n\n  const visitNode = (graphPath: Graph[]) => {\n    let node = graphPath[graphPath.length - 1];\n    node = node.workspace || node;\n    if (seenNodes.has(node)) return;\n    seenNodes.add(node);\n\n    if (node.dependencies) {\n      for (const dep of node.dependencies.values()) {\n        visitNode([...graphPath, dep]);\n      }\n    }\n\n    dependencies.push(node);\n  };\n\n  visitNode([workNode]);\n\n  return dependencies;\n};\n\nconst traverseGraph = (\n  graph: Graph,\n): {\n  allNodes: Set<Graph>;\n  buildNodes: Set<Graph>;\n  nodePathMap: Map<Graph, string>;\n  installState: WorkInstallState;\n} => {\n  const allNodes = new Set<Graph>();\n  const buildNodes = new Set<Graph>();\n  const nodePathMap = new Map<Graph, string>();\n  const installState: WorkInstallState = {};\n\n  const addPathToState = (rootNode: WorkInstallState, pathKind: PathKind, ...segments: string[]): WorkInstallState => {\n    let node = rootNode;\n    for (const segment of segments) {\n      let nextNode = node.nodes?.get(segment);\n      if (!nextNode) {\n        nextNode = {};\n        if (!node.nodes) {\n          node.nodes = new Map();\n        }\n        node.nodes.set(segment, nextNode);\n      }\n\n      node = nextNode;\n    }\n\n    node._pathKind = pathKind;\n\n    return node;\n  };\n\n  const visitNode = (node: Graph, stateNode: InstallState, parentFsPath?: string) => {\n    const { name } = parseSpecifier(node.id);\n    const { scope, packageName } = parseName(node.alias || name);\n\n    const fsPath = node.workspacePath || path.join(parentFsPath!, NODE_MODULES, node.alias || name);\n    nodePathMap.set(node, fsPath);\n\n    if (allNodes.has(node)) return;\n\n    let nmNode;\n    let nextStateNode = stateNode;\n    if (!node.workspacePath) {\n      nmNode = node.parent?.workspacePath ? stateNode : addPathToState(stateNode, PathKind.NODE_MODULES, NODE_MODULES);\n      nmNode._pathKind = PathKind.NODE_MODULES;\n      if (scope) {\n        nextStateNode = addPathToState(addPathToState(nmNode, PathKind.SCOPE, scope), PathKind.PACKAGE, packageName);\n      } else {\n        nextStateNode = addPathToState(nmNode, PathKind.PACKAGE, packageName);\n      }\n      nextStateNode.id = node.id;\n      if (node.workspace) {\n        nextStateNode.isLink = true;\n      }\n    } else {\n      const location = path.join(node.workspacePath, NODE_MODULES);\n      nextStateNode = addPathToState(installState, PathKind.NODE_MODULES, location);\n      nmNode = nextStateNode;\n    }\n\n    if (node.bin) {\n      const binNode = addPathToState(nmNode, PathKind.DOT_BIN, DOT_BIN);\n\n      Object.keys(node.bin).forEach((filename) => {\n        addPathToState(binNode, PathKind.BIN_LINK, filename).id = node.id;\n      });\n    }\n\n    allNodes.add(node);\n\n    if (node.buildScripts) {\n      buildNodes.add(node);\n    }\n\n    for (const dep of node.dependencies || []) {\n      if (dep.parent !== node) continue;\n      visitNode(dep, nextStateNode, fsPath);\n    }\n\n    for (const dep of node.workspaces || []) {\n      visitNode(dep, nextStateNode);\n    }\n  };\n\n  visitNode(graph, installState);\n\n  return { allNodes, buildNodes, nodePathMap, installState };\n};\n\n// Prefer build nodes with least dependencies\nconst getPreferredBuildNodes = (buildDependencies: Map<Graph, Graph[]>): Graph[] =>\n  Array.from(buildDependencies.keys()).sort(\n    (node1, node2) => buildDependencies.get(node1)!.length - buildDependencies.get(node2)!.length,\n  );\n\nexport const installStateDeserializer = (key, value) => {\n  if (key === 'nodes') {\n    return new Map(value);\n  } else {\n    return value;\n  }\n};\n\nexport const installStateSerializer = (key, value) => {\n  if (key === 'nodes') {\n    return Array.from(value.entries());\n  } else if (key.startsWith('_')) {\n    return undefined;\n  } else {\n    return value;\n  }\n};\n\nconst getGraphPath = (node: Graph): Graph[] => {\n  const graphPath: Graph[] = [];\n\n  let currentNode: Graph | undefined = node;\n  do {\n    graphPath.unshift(currentNode);\n    currentNode = currentNode.parent;\n  } while (currentNode);\n\n  return graphPath;\n};\n\nfunction* cleanNode({\n  dirPath,\n  stateNode,\n  prevStateNode,\n  existingPaths,\n}: {\n  dirPath: string;\n  stateNode: WorkInstallState;\n  prevStateNode?: InstallState;\n  existingPaths: Set<string>;\n}): Generator<InstallEvent, undefined, DirEntry[] | undefined> {\n  if (stateNode._cleanStatus) return;\n\n  if (dirPath !== NODE_MODULES && (!stateNode.nodes || !prevStateNode)) {\n    yield { type: InstallEventType.DELETE, targetPath: dirPath };\n    stateNode._cleanStatus = CleanStatus.MISSING;\n    return;\n  }\n\n  const entries = yield { type: InstallEventType.READDIR, targetPath: dirPath };\n  if (!entries) {\n    stateNode._cleanStatus = CleanStatus.MISSING;\n  } else {\n    let canRemoveWholeDir = true;\n    const pathsToRemove = new Map();\n    for (const entry of entries) {\n      if (dirPath === NODE_MODULES && entry.name === RESOLVE_STATE_FILE) {\n        canRemoveWholeDir = false;\n      }\n\n      if (entry.name.startsWith('.') && !stateNode.nodes?.has(entry.name)) continue;\n\n      const targetPath = path.join(dirPath, entry.name);\n      const entryStateNode = stateNode.nodes?.get(entry.name);\n      const prevEntryNode = prevStateNode?.nodes?.get(entry.name);\n      const entryType = entryStateNode\n        ? entryStateNode.isLink || stateNode._pathKind === PathKind.DOT_BIN\n          ? DirEntryType.SYMLINK\n          : DirEntryType.DIRECTORY\n        : undefined;\n\n      const isGoodEntry =\n        entryStateNode &&\n        prevEntryNode &&\n        prevEntryNode.id === entryStateNode.id &&\n        prevEntryNode.isLink === entryStateNode.isLink &&\n        entry.type === entryType;\n      const isWrongEntry =\n        !entryStateNode ||\n        !prevEntryNode ||\n        (entryStateNode &&\n          prevEntryNode &&\n          (entryStateNode.id !== prevEntryNode.id ||\n            entryStateNode.isLink !== prevEntryNode.isLink ||\n            entry.type !== entryType));\n      if (isGoodEntry) {\n        canRemoveWholeDir = false;\n        existingPaths.add(targetPath);\n      } else if (isWrongEntry) {\n        const isInnerNmExists = entryStateNode && entryStateNode.nodes?.get(NODE_MODULES);\n        pathsToRemove.set(targetPath, isInnerNmExists);\n\n        if (entryStateNode && isInnerNmExists) {\n          canRemoveWholeDir = false;\n        }\n      }\n    }\n\n    if (canRemoveWholeDir) {\n      yield { type: InstallEventType.DELETE, targetPath: dirPath };\n      stateNode._cleanStatus = CleanStatus.MISSING;\n    } else {\n      for (const [targetPath, isInnerNmExists] of pathsToRemove) {\n        if (isInnerNmExists) {\n          yield { type: InstallEventType.DELETE, targetPath, cleanOnly: true };\n        } else {\n          yield { type: InstallEventType.DELETE, targetPath };\n        }\n      }\n      stateNode._cleanStatus = CleanStatus.CLEAN;\n    }\n  }\n}\n\nfunction* cleanPackage({\n  pkg,\n  installState,\n  prevState,\n  existingPaths,\n}: {\n  pkg: Graph;\n  installState: WorkInstallState;\n  prevState?: InstallState;\n  existingPaths: Set<string>;\n}): Generator<InstallEvent, undefined, DirEntry[] | undefined> {\n  const graphPath = getGraphPath(pkg);\n\n  let stateNode = installState,\n    prevNode = prevState,\n    parentPath = '.';\n  for (const node of graphPath) {\n    if (node.workspacePath) {\n      parentPath = path.join(node.workspacePath, NODE_MODULES);\n      stateNode = installState.nodes!.get(parentPath)!;\n      prevNode = prevState?.nodes?.get(parentPath);\n\n      yield* cleanNode({ dirPath: parentPath, stateNode, prevStateNode: prevNode, existingPaths });\n    } else {\n      if (stateNode._pathKind === PathKind.NODE_MODULES) {\n        yield* cleanNode({ dirPath: parentPath, stateNode, prevStateNode: prevNode, existingPaths });\n\n        if (stateNode._cleanStatus === CleanStatus.MISSING) break;\n\n        const { name } = parseSpecifier(node.id);\n        const { scope, packageName } = parseName(node.alias || name);\n\n        if (scope) {\n          yield* cleanNode({\n            dirPath: path.join(parentPath, scope),\n            stateNode: stateNode.nodes!.get(scope)!,\n            prevStateNode: prevNode?.nodes?.get(scope),\n            existingPaths,\n          });\n        }\n\n        if (node.bin) {\n          yield* cleanNode({\n            dirPath: path.join(parentPath, '.bin'),\n            stateNode: stateNode.nodes!.get(DOT_BIN)!,\n            prevStateNode: prevNode?.nodes?.get(DOT_BIN),\n            existingPaths,\n          });\n        }\n\n        parentPath = [parentPath]\n          .concat(scope ? [scope] : [])\n          .concat([packageName, NODE_MODULES])\n          .join(path.sep);\n        const packageStateNode = scope ? stateNode.nodes!.get(scope)! : stateNode;\n        const packagePrevNode = scope ? prevNode?.nodes?.get(scope) : prevNode;\n        const nextStateNode = packageStateNode.nodes!.get(packageName)!.nodes?.get(NODE_MODULES);\n        if (nextStateNode) {\n          stateNode = nextStateNode;\n          prevNode = packagePrevNode?.nodes?.get(packageName)?.nodes?.get(NODE_MODULES);\n        }\n      }\n    }\n  }\n}\n\nconst cleanState = (state: WorkInstallState): InstallState | undefined => {\n  let isEmpty = !state.buildFail && !state.buildHash;\n  if (isEmpty) {\n    for (const node of state.nodes!.values()) {\n      if (node.nodes) {\n        isEmpty = false;\n        break;\n      }\n    }\n  }\n\n  if (isEmpty) {\n    return undefined;\n  }\n\n  const cloneNode = (node: WorkInstallState): InstallState => {\n    const clone: any = {};\n    for (const [key, val] of Object.entries(node)) {\n      if (!key.startsWith('_') && key !== 'nodes') {\n        clone[key] = val;\n      }\n    }\n\n    if (node.nodes) {\n      clone.nodes = new Map();\n      for (const [subdir, child] of node.nodes) {\n        clone.nodes.set(subdir, cloneNode(child));\n      }\n    }\n\n    return clone;\n  };\n\n  return cloneNode(state);\n};\n\nconst getStateNode = (targetPath: string, state: InstallState | undefined): InstallState | undefined => {\n  if (targetPath === '.' || !state) return state;\n\n  const segments = targetPath.split(path.sep);\n  const firstNmIndex = targetPath.indexOf(NODE_MODULES);\n  if (firstNmIndex < 0) {\n    throw new Error(`Assertion: unexpected target path: ${targetPath}`);\n  }\n\n  let subdir = segments.slice(0, firstNmIndex + 1).join(path.sep);\n  let node = state.nodes?.get(subdir);\n  for (let idx = firstNmIndex + 1; node && idx < segments.length; idx++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n    node = node?.nodes?.get(segments[idx])!;\n  }\n\n  return node;\n};\n\nconst getBuildHash = (deps: Graph[], nodePathMap: Map<Graph, string>) => {\n  const hash = crypto.createHash('sha1');\n\n  for (const dep of deps) {\n    const targetPath = nodePathMap.get(dep)!;\n    hash.update(`${targetPath}|${dep.id}`);\n  }\n\n  return hash.digest('hex');\n};\n\nexport const setBuildFailures = (state: InstallState, failures: Map<string, string>) => {\n  for (const [targetPath, failedBuild] of failures) {\n    const stateNode = getStateNode(targetPath, state)!;\n    stateNode.buildFail = failedBuild;\n  }\n};\n\nexport const installScript = function* (\n  graph: Graph,\n  prevState?: InstallState,\n): Generator<InstallEvent, InstallState | undefined, DirEntry[] | undefined> {\n  const { allNodes, buildNodes, nodePathMap, installState } = traverseGraph(graph);\n  const buildDependencies = new Map<Graph, Graph[]>();\n\n  for (const buildNode of buildNodes) {\n    const dependencies = getTransitiveDependencies(buildNode);\n    buildDependencies.set(buildNode, dependencies);\n\n    const stateNode = getStateNode(nodePathMap.get(buildNode)!, installState)!;\n    if (!stateNode) {\n      throw new Error(`Unable to find state node for path: ${nodePathMap.get(buildNode)!}`);\n    }\n    stateNode.buildHash = getBuildHash(dependencies, nodePathMap);\n  }\n\n  const buildNodePreferenceList = getPreferredBuildNodes(buildDependencies);\n  const buildNodePreferenceMap = new Map();\n  for (let idx = 0; idx < buildNodePreferenceList.length; idx++) {\n    buildNodePreferenceMap.set(buildNodePreferenceList[idx], idx);\n  }\n\n  const priorityMap = new Map<Graph, number>();\n  let priority = 0;\n  for (const buildNode of buildNodePreferenceList) {\n    const dependencies = buildDependencies.get(buildNode)!;\n    for (const dep of dependencies) {\n      if (!priorityMap.has(dep)) {\n        priorityMap.set(dep, priority);\n        priority++;\n      }\n    }\n  }\n\n  const sortedNodeList = Array.from(allNodes).sort((node1, node2) => {\n    let compareValue = (priorityMap.get(node1) ?? priority) - (priorityMap.get(node2) ?? priority);\n    return compareValue === 0 ? node1.id.localeCompare(node2.id) : compareValue;\n  });\n\n  const existingPaths = new Set<string>();\n\n  const installPaths = new Map<string, string>();\n  const cloneablePaths = new Map<string, string>();\n  for (const node of sortedNodeList) {\n    const targetPath = nodePathMap.get(node)!;\n    yield* cleanPackage({ pkg: node, installState, prevState, existingPaths });\n\n    const isAlreadyUnpacked = existingPaths.has(targetPath);\n    let bin;\n    const binPath = path.join(nodePathMap.get(node.parent || node)!, NODE_MODULES, DOT_BIN);\n    if (node.bin) {\n      for (const [binName, relativePath] of Object.entries(node.bin)) {\n        if (existingPaths.has(path.join(binPath, binName))) {\n          continue;\n        }\n        bin = bin || {};\n        bin[binName] = relativePath;\n      }\n    }\n\n    if (!node.workspacePath && (!isAlreadyUnpacked || bin)) {\n      const sourcePath = cloneablePaths.get(node.id);\n      if (sourcePath) {\n        yield {\n          type: InstallEventType.CLONE,\n          skipUnpack: isAlreadyUnpacked || undefined,\n          sourcePath,\n          targetPath,\n          bin,\n          id: node.id,\n          binPath: bin ? binPath : undefined,\n        };\n      } else {\n        if (node.workspace) {\n          yield { type: InstallEventType.LINK, sourcePath: node.workspace.workspacePath!, targetPath, id: node.id };\n        } else {\n          yield {\n            type: InstallEventType.INSTALL,\n            skipUnpack: isAlreadyUnpacked || undefined,\n            tarballUrl: node.tarballUrl!,\n            targetPath,\n            bin,\n            id: node.id,\n            binPath: bin ? binPath : undefined,\n          };\n        }\n      }\n      if (!isAlreadyUnpacked) {\n        cloneablePaths.set(node.id, targetPath);\n      }\n      installPaths.set(node.id, targetPath);\n    }\n\n    if (node.buildScripts) {\n      const stateNode = getStateNode(targetPath, installState)!;\n      const prevStateNode = getStateNode(targetPath, prevState);\n      if (\n        stateNode &&\n        (isAlreadyUnpacked || node.workspacePath) &&\n        prevStateNode &&\n        stateNode.buildHash === prevStateNode.buildHash &&\n        !prevStateNode.buildFail\n      )\n        continue;\n      const deps = buildDependencies.get(node)!;\n\n      const waitPaths: string[] = [];\n      for (const dep of deps) {\n        if (\n          existingPaths.has(nodePathMap.get(dep)!) ||\n          (dep.workspacePath && (!dep.buildScripts || dep === node)) ||\n          (dep.workspace && !dep.workspace.buildScripts)\n        )\n          continue;\n        const waitPath = installPaths.get(dep.id);\n        if (!waitPath) {\n          throw new Error(`Dependency ${dep.id} wait path not found for parent package: ${node.id}`);\n        }\n        waitPaths.push(waitPath);\n      }\n\n      const buildScripts = new Map();\n      const startIdx =\n        prevStateNode &&\n        prevStateNode.buildFail &&\n        (isAlreadyUnpacked || node.workspacePath) &&\n        prevStateNode.buildHash === stateNode.buildHash\n          ? BUILD_SCRIPTS.indexOf(prevStateNode.buildFail)\n          : 0;\n      for (let idx = startIdx; idx < BUILD_SCRIPTS.length; idx++) {\n        const scriptName = BUILD_SCRIPTS[idx];\n        const scriptLine = node.buildScripts[scriptName];\n        if (typeof scriptLine !== 'undefined') {\n          buildScripts.set(scriptName, scriptLine);\n        }\n      }\n\n      let event: InstallEvent = { type: InstallEventType.BUILD, waitPaths, targetPath, buildScripts, id: node.id };\n\n      if (node.optional) {\n        event.optional = true;\n      }\n\n      if (node.workspace) {\n        event.isWorkspace = true;\n      }\n\n      yield event;\n    }\n  }\n\n  return cleanState(installState);\n};\n", "import { promises as fs, createWriteStream, Dirent } from 'fs';\nimport constants from 'constants';\nimport path from 'path';\nimport { PassThrough, Writable } from 'stream';\nimport { pipeline } from 'stream/promises';\nimport tar from 'tar-stream';\nimport zlib from 'zlib';\n\nimport { Graph } from '../hoister';\nimport { parseSpecifier } from '../resolver';\nimport { CACHE_DIR, cachedCreateDir, atomicFileWrite, isPathExists } from '../cache';\nimport { get } from '../net';\nimport {\n  DirEntry,\n  DirEntryType,\n  InstallEventType,\n  installScript,\n  setBuildFailures,\n  installStateDeserializer,\n  installStateSerializer,\n} from './installScript';\nimport { runCommand } from '../runCommand';\nimport { NODE_MODULES } from '../constants';\n\nconst INSTALL_STATE_PATH = path.join(NODE_MODULES, '.install-state.json');\nconst INSTALL_STATE_VERSION = '1';\n\ntype TarballEntry = { location: string; mode: number };\ntype TarballMap = Map<string, TarballEntry[]>;\n\nconst downloadTarball = async (name: string, version: string, tarballUrl: string): Promise<Buffer> => {\n  if (!tarballUrl) {\n    throw new Error(`tarball url is empty for ${name}@${version}`);\n  }\n\n  const response = await get(tarballUrl);\n  if (response.statusCode !== 200) {\n    throw new Error(\n      `Received ${response.statusCode}: ${response.statusMessage} from the registry while downloading ${tarballUrl}`,\n    );\n  } else {\n    const unzip = zlib.createGunzip();\n    const chunks: Buffer[] = [];\n\n    await pipeline(\n      response,\n      unzip,\n      new Writable({\n        write(chunk, _encoding, callback) {\n          chunks.push(chunk);\n          callback();\n        },\n      }),\n    );\n\n    const body = Buffer.concat(chunks);\n\n    if (body.length === 0) {\n      throw new Error(`Received empty tarball from ${tarballUrl}, response status: ${response.statusCode}`);\n    }\n\n    await atomicFileWrite(getTarballCacheFilePath(name, version), body);\n\n    return body;\n  }\n};\n\nconst unpackTarball = async (dirPath: string, buffer: Buffer): Promise<TarballEntry[]> => {\n  const extract = tar.extract();\n\n  const entries: TarballEntry[] = [];\n\n  const passthrough = new PassThrough();\n\n  extract.on('entry', (header, stream, next) => {\n    const relativeEntryPath = header.name.substring(header.name.indexOf('/') + 1);\n    const entryPath = path.join(dirPath, relativeEntryPath);\n\n    if (header.type === 'file') {\n      (async () => {\n        await cachedCreateDir(path.dirname(entryPath));\n\n        await pipeline(stream, createWriteStream(entryPath));\n\n        if (header.mode & constants.S_IXUSR) {\n          entries.push({ location: relativeEntryPath, mode: 0o755 });\n          await fs.chmod(entryPath, 0o755);\n        } else {\n          entries.push({ location: relativeEntryPath, mode: 0o664 });\n        }\n\n        next();\n      })();\n    } else {\n      next();\n    }\n  });\n\n  passthrough.end(buffer);\n\n  await pipeline(passthrough, extract);\n\n  return entries;\n};\n\nconst getTarballBaseName = (name: string, version: string): string => `${name.replaceAll('/', '+')}-${version}`;\nconst getTarballName = (name: string, version: string): string => `${getTarballBaseName(name, version)}.tar`;\n\nconst getTarballCacheFilePath = (name: string, version: string): string => {\n  const filename = getTarballName(name, version);\n  const filePath = path.join(CACHE_DIR, 'tarballs', filename);\n  return filePath;\n};\n\nconst getCachedTarball = async (name: string, version: string): Promise<Buffer | null> => {\n  const filePath = getTarballCacheFilePath(name, version);\n\n  const isFileCached = await isPathExists(filePath);\n\n  if (isFileCached) {\n    const buffer = await fs.readFile(filePath);\n\n    if (buffer.length === 0) {\n      throw new Error(`Empty tarball at ${filePath}`);\n    }\n\n    return buffer;\n  } else {\n    return null;\n  }\n};\n\nconst installBin = async ({\n  bin,\n  binSet,\n  dirPath,\n  binPath,\n}: {\n  bin: any;\n  binSet: Set<string>;\n  dirPath: string;\n  binPath: string;\n}) => {\n  if (bin) {\n    await cachedCreateDir(binPath);\n\n    for (const [scriptName, scriptPath] of Object.entries<string>(bin)) {\n      const dstPath = path.join(binPath, scriptName);\n      if (binSet.has(dstPath)) continue;\n      binSet.add(dstPath);\n\n      const srcPath = path.join(dirPath, scriptPath);\n\n      await fs.rm(dstPath, { force: true });\n      await fs.chmod(srcPath, 0o755);\n      await fs.symlink(path.relative(path.dirname(dstPath), srcPath), dstPath);\n    }\n  }\n};\n\nconst installTask = async ({\n  id,\n  targetPath,\n  tarballMap,\n  tarballUrl,\n  bin,\n  binSet,\n  binPath,\n  skipUnpack,\n}: {\n  id: string;\n  targetPath: string;\n  tarballUrl: string;\n  tarballMap: TarballMap;\n  bin?: Record<string, string>;\n  binSet: Set<string>;\n  binPath: string;\n  skipUnpack: string;\n}) => {\n  if (!skipUnpack) {\n    const { name, range: version } = parseSpecifier(id);\n\n    let buffer = await getCachedTarball(name, version);\n\n    if (!buffer) {\n      buffer = await downloadTarball(name, version, tarballUrl);\n    }\n\n    const entries = await unpackTarball(targetPath, buffer);\n    tarballMap.set(id, entries);\n  }\n\n  await installBin({ bin, dirPath: targetPath, binSet, binPath });\n  // console.log('install', nmPath);\n};\n\nconst cloneTask = async ({\n  id,\n  sourcePath,\n  targetPath,\n  bin,\n  binSet,\n  tarballMap,\n  binPath,\n}: {\n  id: string;\n  sourcePath: string;\n  targetPath: string;\n  bin?: Record<string, string>;\n  binSet: Set<string>;\n  tarballMap: TarballMap;\n  binPath: string;\n}) => {\n  const entries = tarballMap.get(id);\n  if (!entries) {\n    throw new Error(`No info of tarball entries for package ${id}`);\n  }\n\n  for (const entry of entries) {\n    const srcPath = path.join(sourcePath, entry.location);\n    const dstPath = path.join(targetPath, entry.location);\n\n    await cachedCreateDir(path.dirname(dstPath));\n    await fs.copyFile(srcPath, dstPath, constants.COPYFILE_FICLONE);\n    if (entry.mode & constants.S_IXUSR) {\n      await fs.chmod(dstPath, 0o755);\n    }\n  }\n\n  await installBin({ bin, dirPath: targetPath, binSet, binPath });\n};\n\nconst linkTask = async ({ sourcePath, targetPath }: { sourcePath: string; targetPath: string }) => {\n  await cachedCreateDir(path.dirname(targetPath));\n  await fs.symlink(path.relative(path.dirname(targetPath), sourcePath), targetPath);\n  // console.log('link', dstPath, '->', srcPath);\n};\n\nconst buildTask = async ({\n  id,\n  targetPath,\n  isWorkspace,\n  optional,\n  buildScripts,\n  buildFailures,\n}: {\n  id: string;\n  targetPath: string;\n  isWorkspace: boolean;\n  optional?: boolean;\n  buildScripts: Map<string, string>;\n  buildFailures: Map<string, string>;\n}) => {\n  for (const [scriptName, script] of buildScripts) {\n    const timeStart = Date.now();\n    const { code, output } = await runCommand(targetPath, scriptName, script, [], true);\n    const timeEnd = Date.now();\n    if (isWorkspace || (!optional && code !== 0)) {\n      const finalOutput = output.trimEnd();\n      console.log(`\u250C\u2500${id} -> ${scriptName} at ${targetPath}`);\n      if (finalOutput.length > 0) {\n        const lines = finalOutput.split('\\n');\n        for (const line of lines) {\n          console.log(`\u2502 ${line}`);\n        }\n      }\n      console.log(`\u2514\u2500\u2500\u2500${code === 0 ? '' : ' failed with code: ' + code} ${timeEnd - timeStart}ms`);\n    }\n\n    if (code !== 0 && !optional) {\n      buildFailures.set(targetPath, scriptName);\n      break;\n    }\n  }\n};\n\nconst getDirEntryType = (entry: Dirent): DirEntryType => {\n  if (entry.isSymbolicLink()) {\n    return DirEntryType.SYMLINK;\n  } else if (entry.isDirectory()) {\n    return DirEntryType.DIRECTORY;\n  } else {\n    return DirEntryType.FILE;\n  }\n};\n\nconst deleteDir = async ({ targetPath, cleanOnly }: { targetPath: string; cleanOnly: boolean }) => {\n  if (!cleanOnly) {\n    await fs.rm(targetPath, { force: true, recursive: true });\n  } else {\n    const entries = await fs.readdir(targetPath);\n    for (const entry in entries) {\n      if (entry === NODE_MODULES) continue;\n      await fs.rm(path.join(targetPath, entry), { force: true, recursive: true });\n    }\n  }\n};\n\nexport const write = async (graph: Graph) => {\n  let prevState;\n  let prevStateText;\n  try {\n    prevStateText = await fs.readFile(INSTALL_STATE_PATH, 'utf8');\n    prevState = JSON.parse(prevStateText, installStateDeserializer);\n  } catch {\n    // empty\n  }\n\n  const script = installScript(graph, prevState);\n  const installTasks = new Map<string, Promise<any>>();\n  const buildTasks = new Map<string, Promise<any>>();\n  const buildFailures = new Map<string, string>();\n  const binSet = new Set<string>();\n  const tarballMap: TarballMap = new Map();\n\n  let next;\n  let nextArg: DirEntry[] | undefined;\n\n  try {\n    do {\n      next = script.next(nextArg);\n      nextArg = undefined;\n\n      if (next.done) break;\n\n      const step = next.value;\n      const { targetPath } = step;\n\n      if (step.type === InstallEventType.READDIR) {\n        let entries: Dirent[] = [];\n        try {\n          entries = await fs.readdir(targetPath, { withFileTypes: true });\n        } catch {\n          // empty\n        }\n\n        nextArg = entries.map((entry) => ({ name: entry.name, type: getDirEntryType(entry) }));\n      } else if (step.type === InstallEventType.DELETE) {\n        await deleteDir({ targetPath, cleanOnly: step.cleanOnly });\n      }\n      if (step.type === InstallEventType.INSTALL) {\n        installTasks.set(\n          targetPath,\n          installTask({\n            id: step.id,\n            targetPath,\n            tarballUrl: step.tarballUrl,\n            tarballMap,\n            binSet,\n            bin: step.bin,\n            binPath: step.binPath,\n            skipUnpack: step.skipUnpack,\n          }),\n        );\n      } else if (step.type === InstallEventType.CLONE) {\n        const { sourcePath } = step;\n        const installPromise = installTasks.get(sourcePath);\n        if (!installPromise) {\n          throw new Error('Assertion: nothing to clone');\n        }\n        installTasks.set(\n          targetPath,\n          installPromise.then(() =>\n            cloneTask({\n              id: step.id,\n              sourcePath,\n              targetPath,\n              tarballMap,\n              binSet,\n              bin: step.bin,\n              binPath: step.binPath,\n            }),\n          ),\n        );\n      } else if (step.type === InstallEventType.LINK) {\n        installTasks.set(targetPath, linkTask({ sourcePath: step.sourcePath, targetPath }));\n      } else if (step.type === InstallEventType.BUILD) {\n        const waitTasks: Promise<any>[] = [];\n        for (const waitPath of step.waitPaths) {\n          const installPromise = installTasks.get(waitPath)!;\n          waitTasks.push(installPromise);\n          const buildPromise = buildTasks.get(waitPath);\n          if (buildPromise) {\n            waitTasks.push(buildPromise);\n          }\n        }\n\n        buildTasks.set(\n          targetPath,\n          Promise.all(waitTasks).then(() =>\n            buildTask({\n              id: step.id,\n              targetPath,\n              optional: step.optional,\n              isWorkspace: step.isWorkspace,\n              buildScripts: step.buildScripts,\n              buildFailures,\n            }),\n          ),\n        );\n      }\n    } while (!next.done);\n  } finally {\n    await Promise.all(installTasks.values());\n    await Promise.all(buildTasks.values());\n  }\n\n  if (next && next.value) {\n    const installState = next.value;\n    installState.version = INSTALL_STATE_VERSION;\n    setBuildFailures(installState, buildFailures);\n\n    await cachedCreateDir(NODE_MODULES);\n\n    const newStateText = JSON.stringify(installState, installStateSerializer, 0);\n    if (newStateText !== prevStateText) {\n      if (prevStateText) console.log('install state changed');\n      if (prevStateText) {\n        await fs.writeFile(INSTALL_STATE_PATH + '.old', JSON.stringify(JSON.parse(prevStateText), null, 2));\n        await fs.writeFile(INSTALL_STATE_PATH + '.new', JSON.stringify(JSON.parse(newStateText), null, 2));\n      }\n      await fs.writeFile(INSTALL_STATE_PATH, newStateText);\n    }\n  } else {\n    console.log('deleted install state');\n    await fs.rm(INSTALL_STATE_PATH, { force: true });\n  }\n\n  return buildFailures.size === 0 ? 0 : 1;\n};\n", "import child from 'child_process';\nimport path from 'path';\n\nimport { DOT_BIN, NODE_MODULES } from './constants';\n\nexport const runCommand = async (\n  cwd: string,\n  scriptName: string,\n  script: any,\n  args: any[],\n  buffer: boolean,\n): Promise<{ output: string; code: number }> => {\n  if (typeof script === 'undefined') {\n    console.error(`Command ${scriptName} not found`);\n    return { output: '', code: 1 };\n  }\n\n  const cmd = [script, ...args].join(' ');\n  const env: any = {\n    NODE: process.execPath,\n    INIT_CWD: process.cwd(),\n    ...process.env,\n  };\n\n  env.npm_lifecycle_event = scriptName;\n  env.npm_node_execpath = env.NODE;\n  env.npm_execpath = env.npm_execpath || (require.main && require.main.filename);\n\n  const pathList: string[] = [];\n\n  const nodeModulesParts = path.resolve(cwd).split(path.sep + NODE_MODULES + path.sep);\n  const currentParts: string[] = [];\n  for (const part of nodeModulesParts) {\n    currentParts.push(part);\n    pathList.unshift(path.join(currentParts.join(path.sep + NODE_MODULES + path.sep), NODE_MODULES, DOT_BIN));\n  }\n\n  pathList.push(path.dirname(process.argv[1]));\n  const envPathList: string[] = env.PATH ? env.PATH.split(path.delimiter) : [];\n  for (const pathElement of envPathList) {\n    pathList.push(pathElement);\n  }\n  env.PATH = pathList.join(path.delimiter);\n\n  const options: any = { env, detached: false, shell: true, cwd };\n  if (!buffer) {\n    options.stdio = 'inherit';\n  }\n\n  let output = ``;\n\n  const task = child.spawn(cmd, [], options);\n\n  if (buffer) {\n    task.stdout.on('data', (chunk) => {\n      output += chunk.toString('utf8');\n    });\n\n    task.stderr.on('data', (chunk) => {\n      output += chunk.toString('utf8');\n    });\n  }\n\n  let promise, resolve;\n\n  promise = new Promise((r) => (resolve = r));\n  task.on('exit', (code) => resolve({ output, code }));\n\n  return await promise;\n};\n", "import { CheckType, hoist } from '../../hoister';\nimport { ensureCacheDirExists } from '../../cache';\nimport { resolve } from '../../resolver';\nimport { write } from '../../installer';\nimport { ResolveOptions } from '../../resolver/resolver';\nimport { TOOL_NAME, VERSION } from '../../constants';\n\nexport const install = async (options?: ResolveOptions): Promise<number> => {\n  if (!options?.skipBanner) {\n    console.log(`${TOOL_NAME} install ${VERSION}`);\n  }\n\n  const resolveStart = Date.now();\n  await ensureCacheDirExists();\n  const graph = await resolve(options);\n  const resolveEnd = Date.now();\n  const resolveTime = (resolveEnd - resolveStart) / 1000.0;\n  console.log(`Resolution done in ${resolveTime}s`);\n  const hoistedGraph = hoist(graph, { check: CheckType.FINAL });\n\n  const installStart = Date.now();\n  await write(hoistedGraph);\n  const installEnd = Date.now();\n  const installTime = (installEnd - installStart) / 1000.0;\n  console.log(`Installing done in ${installTime}s`);\n\n  const totalTime = (installEnd - resolveStart) / 1000.0;\n\n  console.log(`Total time: ${totalTime}s `);\n\n  return 0;\n};\n", "import { promises as fs } from 'fs';\nimport detectIndent from 'detect-indent';\n\nimport { ensureCacheDirExists } from '../../cache';\nimport { install } from '../install';\nimport { removeScript, RemoveEventType } from './removeScript';\nimport { TOOL_NAME, VERSION } from '../../constants';\n\nexport const remove = async (nameList: string[]): Promise<number> => {\n  console.log(`${TOOL_NAME} remove ${VERSION}`);\n  await ensureCacheDirExists();\n  let isModified = false;\n\n  const packageJsonPath = 'package.json';\n  const text = await fs.readFile(packageJsonPath, 'utf8');\n  const indent = detectIndent(text).indent || '  ';\n  const json = JSON.parse(text);\n\n  const script = removeScript({ json }, nameList);\n  let hasErrors = false;\n\n  let next;\n  do {\n    next = script.next();\n\n    if (next.done) break;\n\n    const step = next.value;\n    if (step.type === RemoveEventType.MODIFY) {\n      const newText = JSON.stringify(step.json, undefined, indent);\n      if (newText !== text) {\n        console.log('package.json changed');\n        isModified = true;\n        await fs.writeFile(packageJsonPath, newText);\n      }\n    } else if (step.type === RemoveEventType.NOT_FOUND) {\n      hasErrors = true;\n      console.error(step.message);\n    }\n  } while (!next.done);\n\n  if (isModified) {\n    return await install({ skipBanner: true });\n  } else {\n    return hasErrors ? 1 : 0;\n  }\n};\n", "import { PurePackage } from '../../resolver/workspace';\nimport { DEPENDENCY_TYPES } from '../../constants';\n\nexport enum RemoveEventType {\n  MODIFY = 'modify',\n  NOT_FOUND = 'not_found',\n}\n\nexport type RemoveEvent =\n  | {\n      type: RemoveEventType.MODIFY;\n      json: any;\n    }\n  | {\n      type: RemoveEventType.NOT_FOUND;\n      message: string;\n    };\n\nexport const removeScript = function* (pkg: PurePackage, nameList: string[]): Generator<RemoveEvent, any, any> {\n  let isModified = false;\n  const nextJson = structuredClone(pkg.json);\n\n  for (const name of nameList) {\n    let found = false;\n    for (const dependencyType of DEPENDENCY_TYPES) {\n      if (nextJson[dependencyType] && nextJson[dependencyType][name]) {\n        delete nextJson[dependencyType][name];\n        if (Object.keys(nextJson[dependencyType]).length === 0) {\n          delete nextJson[dependencyType];\n        }\n\n        found = true;\n        isModified = true;\n      }\n    }\n\n    if (!found) {\n      yield { type: RemoveEventType.NOT_FOUND, message: `The module '${name}' is not present in the 'package.json'` };\n      isModified = false;\n      break;\n    }\n  }\n\n  if (isModified) {\n    yield { type: RemoveEventType.MODIFY, json: nextJson };\n  }\n};\n"],
  "mappings": "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",
  "names": ["exports", "CommanderError", "InvalidArgumentError", "exports", "InvalidArgumentError", "Argument", "exports", "Help", "cmd", "exports", "InvalidArgumentError", "Option", "str", "exports", "exports", "path", "fs", "process", "Argument", "CommanderError", "Help", "Option", "Command", "write", "option", "exports", "Argument", "Command", "CommanderError", "InvalidArgumentError", "Help", "Option", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "require_valid", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "require_semver", "exports", "module", "constants", "exports", "node", "exports", "module", "child", "exports", "module", "exports", "module", "max", "exports", "module", "exports", "module", "child", "exports", "module", "child", "require_constants", "exports", "module", "require_parse", "exports", "module", "index", "exports", "module", "require_constants", "exports", "module", "path", "require_utils", "exports", "path", "exports", "module", "require_parse", "exports", "module", "constants", "opts", "value", "rest", "source", "exports", "module", "path", "constants", "state", "require_picomatch", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "fill", "write", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "data", "resolve", "Writable", "PassThrough", "pipeline", "onerror", "exports", "exports", "module", "Writable", "resolve", "require_constants", "exports", "module", "constants", "exports", "module", "Writable", "constants", "exports", "commander", "import_fs", "import_detect_indent", "import_path", "path", "fs", "path", "os", "crypto", "import_fs", "import_path", "https", "dns", "resolve", "path", "fs", "zlib", "import_semver", "import_fs", "import_path", "import_fs", "import_path", "mm", "json", "fs", "path", "usedBy", "route", "parent", "cloneNode", "node", "wasGraphChanged", "semver", "version", "pkg", "getPackageName", "name", "print", "minimizeMetadata", "seen", "path", "fs", "detectIndent", "semver", "import_path", "import_crypto", "path", "getGraphPath", "cloneNode", "child", "crypto", "import_fs", "import_constants", "import_path", "import_stream", "import_promises", "import_zlib", "import_path", "path", "child", "resolve", "path", "zlib", "tar", "constants", "fs", "getMetadata", "fs", "detectIndent", "import_fs", "import_detect_indent", "fs", "detectIndent"]
}
