#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var import_cli = require("./cli");
var import_fs = require("fs");
var import_path3 = __toESM(require("path"));

// src/runCommand.ts
var import_child_process = __toESM(require("child_process"));
var import_path2 = __toESM(require("path"));

// src/constants.ts
var import_path = __toESM(require("path"));

// package.json
var package_default = {
  name: "nari",
  version: "0.0.7",
  bin: "./lib/nari",
  scripts: {
    build: "rm -rf ./lib && esbuild src/index.ts --sourcemap --bundle --platform=node --target=node18 --external:./cli --outfile=lib/nari '--banner:js=#!/usr/bin/env node' && chmod +x lib/nari && esbuild src/cli/index.ts --sourcemap --bundle --platform=node --target=node18 --outfile=lib/cli.js",
    test: "jest",
    nari: "nari build && node --enable-source-maps lib/nari",
    "test:watch": "jest --watch",
    lint: "eslint --fix",
    prepack: "nari build && nari lint && nari test"
  },
  repository: {
    type: "git",
    url: "https://github.com/narijs/nari"
  },
  bugs: {
    url: "https://github.com/narijs/nari/issues"
  },
  keywords: [
    "modules",
    "install",
    "package manager"
  ],
  author: "SysGears (Cyprus) Limited",
  license: "MIT",
  devDependencies: {
    "@types/jest": "^29.5.13",
    "@types/node": "^22.7.4",
    "@typescript-eslint/eslint-plugin": "^8.7.0",
    "@typescript-eslint/parser": "^8.7.0",
    commander: "^12.1.0",
    "detect-indent": "^6.0.0",
    micromatch: "^4.0.8",
    semver: "^7.6.3",
    "tar-stream": "^3.1.7",
    esbuild: "^0.24.0",
    "esbuild-jest": "^0.5.0",
    eslint: "^9.11.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-header": "^3.1.1",
    "eslint-plugin-jest": "^28.8.3",
    "eslint-plugin-prettier": "^5.2.1",
    husky: "^9.1.6",
    jest: "^29.7.0",
    "lint-staged": "^15.2.10",
    prettier: "^3.3.3",
    typescript: "~5.5.0"
  },
  "lint-staged": {
    "*.ts": [
      "eslint --fix -c tslint.json",
      "git add"
    ]
  },
  prettier: {
    printWidth: 120,
    singleQuote: true,
    parser: "typescript"
  },
  husky: {
    "pre-commit": "lint-staged"
  },
  lockTime: "2024-10-02T12:40:33.928Z"
};

// src/constants.ts
var VERSION = package_default.version;
var TOOL_NAME = "nari";
var NODE_MODULES = "node_modules";
var DOT_BIN = ".bin";
var DOWNLOAD_DIR = import_path.default.join(NODE_MODULES, `.${TOOL_NAME}`);

// src/runCommand.ts
var runCommand = async (cwd, scriptName, script, args, buffer) => {
  if (typeof script === "undefined") {
    console.error(`Command ${scriptName} not found`);
    return { output: "", code: 1 };
  }
  const cmd = [script, ...args].join(" ");
  const env = {
    NODE: process.execPath,
    INIT_CWD: process.cwd(),
    ...process.env
  };
  env.npm_lifecycle_event = scriptName;
  env.npm_node_execpath = env.NODE;
  env.npm_execpath = env.npm_execpath || require.main && require.main.filename;
  const pathList = [];
  const nodeModulesParts = import_path2.default.resolve(cwd).split(import_path2.default.sep + NODE_MODULES + import_path2.default.sep);
  const currentParts = [];
  for (const part of nodeModulesParts) {
    currentParts.push(part);
    pathList.unshift(import_path2.default.join(currentParts.join(import_path2.default.sep + NODE_MODULES + import_path2.default.sep), NODE_MODULES, DOT_BIN));
  }
  pathList.push(import_path2.default.dirname(process.argv[1]));
  const envPathList = env.PATH ? env.PATH.split(import_path2.default.delimiter) : [];
  for (const pathElement of envPathList) {
    pathList.push(pathElement);
  }
  env.PATH = pathList.join(import_path2.default.delimiter);
  const options = { env, detached: false, shell: true, cwd };
  if (!buffer) {
    options.stdio = "inherit";
  }
  let output = ``;
  const task = import_child_process.default.spawn(cmd, [], options);
  if (buffer) {
    task.stdout.on("data", (chunk) => {
      output += chunk.toString("utf8");
    });
    task.stderr.on("data", (chunk) => {
      output += chunk.toString("utf8");
    });
  }
  let promise, resolve;
  promise = new Promise((r) => resolve = r);
  task.on("exit", (code) => resolve({ output, code }));
  return await promise;
};

// src/index.ts
var commands = ["add", "i", "install", "remove", "pack", "publish"];
(async () => {
  let exitCode;
  const isOptionSupplied = process.argv.length > 2 && process.argv[2].startsWith("-") || process.argv.length > 3 && commands.indexOf(process.argv[2]) >= 0 && process.argv[3].startsWith("-");
  if (!isOptionSupplied && process.argv.length > 2 && commands.indexOf(process.argv[2]) < 0) {
    const packageJson = JSON.parse(await import_fs.promises.readFile("./package.json", "utf-8"));
    const scriptNameIndex = process.argv[2] === "run" ? 3 : 2;
    const scriptName = process.argv[scriptNameIndex];
    let script = (packageJson.scripts || {})[scriptName];
    if (typeof script === "undefined") {
      const dotBinPath = import_path3.default.join(NODE_MODULES, DOT_BIN);
      const binaries = await import_fs.promises.readdir(dotBinPath);
      if (binaries.indexOf(scriptName) >= 0) {
        script = scriptName;
      }
    }
    exitCode = (await runCommand(process.cwd(), scriptName, script, process.argv.slice(scriptNameIndex + 1), false)).code;
  } else {
    exitCode = await (0, import_cli.cli)();
  }
  process.exit(exitCode);
})();
//# sourceMappingURL=nari.map
